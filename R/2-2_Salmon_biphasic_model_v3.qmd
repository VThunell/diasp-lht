---
title: "Salmon Biphasic model 4"
author: "Viktor Thunell" 
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    code-fold: true
    code-summary: "Show code"
    page-layout: full
    embed-resources: true
    toc: true
knitr: 
  opts_chunk:
    fig.align: center
    out-width: 80%
editor: source
execute: 
  echo: true
  eval: true
  cache: true
---

## Load libraries

```{r libs}
#| message: false
#| warning: false
#| cache: false

# Load libraries, install if needed
pkgs <- c("tidyverse", "tidylog", "devtools","viridis","nls.multstart", "broom", "patchwork", "coda", "boot", "tidybayes","bayesplot", "nimbleHMC", "here")

# remotes::install_github("nimble-dev/nimble", ref = "devel", subdir = "packages/nimble")

if(length(setdiff(pkgs,rownames(installed.packages()))) > 0){
    install.packages(setdiff(pkgs, rownames(installed.packages())), dependencies = T)
  }

invisible(lapply(pkgs, library, character.only = T))

options(ggplot2.continuous.colour = "viridis")
theme_set(theme_light()) # check why global theme option not working when rendering
# Set path
color_scheme_set("viridis")
home <- here::here()
```

## Read data

```{r}
#| message: false
#| warning: false
#| cache: false

sallaa <- readRDS(file = paste0(home,"/data/data-for-2-2/salmon-laa_2025-09-04.RData")) %>%
  rename(year = fi_year,
         site = sai_location,
         sea.age = sea_age_year,
         juv.age = juvenile_age_year,
         tot.age = tot_age_year,
         lat = fisa_y_4326,
         lon = fisa_x_4326) %>%
  #filter out non-aged individuals (~90000 individuals)
  filter(!(is.na(sea.age) & is.na(juv.age)))

```

## Plot data
```{r plot dat}
sallaa %>%
  drop_na(sex) %>%
  ggplot(aes(tot.age, length_mm, color = sex)) +
  geom_point() +
  facet_grid(age.type~sex) +
  scale_x_continuous(breaks = seq(0, 13, 1) ) +
  theme_light() 

# If dropping all inds where both sea and sm age is NA
sallaa %>% 
  ggplot() +
  geom_density(aes(x = tot.age), fill = "deeppink", alpha = 0.5) +
  xlim(0, 13) +

sallaa %>% 
  ggplot() + 
  geom_density(aes(x = length_mm), fill = "deeppink", alpha = 0.5)

sallaa %>% 
  drop_na(sea.age) %>%
  ggplot() +
  geom_density(aes(x = length_mm, fill = factor(tot.age)), alpha = 0.5) +
  facet_wrap(~tot.age)

# age at smoltification by spatial unit
sallaa %>% 
  filter(age.type == "both") %>%
  ggplot() +
  geom_density(aes(x = juv.age, color = spat.unit),  alpha = 0.5) +
  facet_wrap(~spat.unit) +
  xlim(-1, 5)

# juvenile size at age
sallaa %>%
  filter(age.type == "juve.only") %>%
  ggplot(aes(x = juv.age, y =length_mm, color = spat.unit)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = lm) +
  facet_wrap(~spat.unit)

# size at age zero
sallaa %>%
  filter(!age.type == "sea.only",
         tot.age == 0) %>%
  ggplot() +
  geom_density(aes(x = length_mm), fill = "deeppink", alpha = 0.5) +
  labs(title = "Age 0")
  
```

## Biphasic 4
Spatiotemporal model for g and par.

Check 
- ages and sizes of smolts and pre smolts
- 
```{r model}

biph4.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    length_mm[i] ~ dnorm(l.mu[age.index[i], ind.id[i]], sd = sig.l)
    }
  
  # Estimate length at age for each individual (j in nn) and for each age of j (k in age.index=1 to age.index[j], i.e. age 0 to catch age)
  for(j in 1:nn){
    l.mu[1,j] <- lb.mu[spat.unit[j]]# old:+ g[spat.unit[j], hatch.year.f[j]] # age
    
    for(k in 2:age.index[j]+1){
    #Say that we for hatch.year=2010 want to predict length of an individual of age 3. If we then want to use environmental conditions in 2012 to predict length in 2013, year should be hatch.year + 2 = 2012 but here k = age + 1 = 4. Using k, we need hatch.year + k - 2. BUT, this makes for using hatch year for both k=1 (in l.mu[1,j]) and k=2. Furtherm. k-1 has different meaning in the step for smolt age.
    l.mu[k,j] <- l.mu[k-1,j] + step(smo.age[j] - (k-1))*exp(g[spat.unit[j], (hatch.year.f[j]+k-2)]) +
      (1-step(smo.age[j] - (k-1)))*((exp(par[spat.unit[j],(hatch.year.f[j]+k-2),1]) - l.mu[k-1,j])*(1 - exp(-exp(par[spat.unit[j],(hatch.year.f[j]+k-2),2]) #*(1 + (tot.age[j] %% 1))
      )))
    }
  }
  
  # estimate smo.age. 
  for(l in 1:nn){
    smo.age[l] ~ dgamma(shape = sh.sm[spat.unit[l]], scale = sc.sm)
    }
  
  # Priors  
  sig.l ~ dexp(1/500)
  #lb.mu ~ dnorm(17, sd = 5) # ~15 to 20 mm, https://doi.org/10.1111/j.1095-8649.2009.02497.x sd arbitary/guesstimate
  
  # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars])

  # priors for smolt age and juvenile growth rate
  
  sc.sm <- 0.5^2/2.5 # shape = 2.5^2/.5^2 = 25, #From mean=shape*scale, var=shape*scale^2 -> shape = mean^2/var & scale = var/mean. mean=2.5, sd=0.5.
  
  for(i in 1:nsu){
    sh.sm[i] ~ dnorm(25, sd = 5) # dgamma shape param, sd is arbitrary
    lb.mu[i] ~ dnorm(100, sd = 25) # FIX prior
    for(j in minyear:maxyear){ # Take into accuount hatch.year[j]+k-1
      par[i,j,1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
      g[i,j] ~ dnorm(mean = g_lmean, sd = g_lsd) # LOG SCALE and weak prior
    }
  }
  
  g_lsd <- sqrt(log(1 + (10^2) / (50^2))) # sqrt of variance (= sd) of the lognormal distr. 50 and 10 is arbitrary atm.
  g_lmean <- log(50) - 0.5 * g_lsd^2  # mean of the lognorm distr.
  
  mu_par[1] ~ dnorm(mean = l_lmean, sd = l_lsd)
  mu_par[2] ~ dnorm(mean = k_lmean, sd = k_lsd)
  sig_par[1] ~ dlnorm(0,1)
  sig_par[2] ~ dlnorm(0,1)

  # K & l values from fb  
  k_lsd <- sqrt(log(1 + (0.28^2) / (0.43^2))) 
  k_lmean <- log(0.43) - 0.5 * k_lsd^2  
  l_lsd <- sqrt(log(1 + (278^2) / (1378^2))) 
  l_lmean <- log(1378) - 0.5 * l_lsd^2
  })

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k'))))

data <- sallaa %>%
  filter(!age.type == "sea.only",
         !is.na(year),
         year > 2000
         ) %>% 
  slice_sample(n = 2000) %>%
  mutate(# create smolt age (!IMPROVE from data using fi_lfs_code)
         smo.age = if_else(age.type == "both", juv.age, NA),
         sea.age = if_else(is.na(sea.age), 0, sea.age),
         age.index = as.integer(tot.age + 1), # index for l.mu, + 1 to include age 0 individuals
         hatch.year = year-tot.age,
         hatch.year.f = as.numeric(factor(hatch.year, levels = sort(unique(hatch.year)), labels = seq_along(sort(unique(hatch.year))))),
         year.f = as.integer(factor(year)),
         spat.unit = as.integer(factor(spat.unit))) %>%
  select(smo.age, tot.age, length_mm, age.index, year, spat.unit, hatch.year, hatch.year.f) %>%
  mutate(ind.id = row_number()) # ind id

npars <- 2
# get max year by, needed as hatch.year is integer and the last year is not (simpler solution?).  
maxyear <- max(data$hatch.year.f) + data %>% 
  filter(year == max(year)) %>% 
  filter(tot.age == max(tot.age)) %>% 
  distinct(tot.age) %>% pull(tot.age) 

# build model
biph4.model <- nimbleModel(biph4.code,
                           constants = list(npars = npars,
                                             nobs = nrow(data),
                                             nn = nrow(data), # change when >1 sample per ind.id
                                             nsu = length(unique(data$spat.unit)),
                                             age.index = data$age.index, 
                                             ind.id = data$ind.id,
                                             hatch.year.f = data$hatch.year.f,
                                             minyear = min(data$hatch.year.f),
                                             maxyear = maxyear,
                                             spat.unit = data$spat.unit),
                           data = data %>% select(-ind.id,-age.index,-spat.unit,-hatch.year,-tot.age, -year, -hatch.year.f))

# check values 
biph4.model$simulate("sig.l")
biph4.model$simulate("mu_par")
biph4.model$simulate("sig_par")
biph4.model$simulate("Ustar")
biph4.model$simulate("U")
biph4.model$simulate("sh.sm")
biph4.model$simulate("smo.age")
biph4.model$simulate("lb.mu")
biph4.model$simulate("g")
biph4.model$simulate("par")
biph4.model$simulate("l.mu")

biph4.model$sig.l
biph4.model$U
biph4.model$Ustar
biph4.model$mu_par
biph4.model$sig_par
biph4.model$sh.sm
biph4.model$smo.age[1:50]
biph4.model$lb.mu
exp(biph4.model$g)
exp(biph4.model$par[1:11,1:20,1]) #linf
exp(biph4.model$par[1:11,1:20,2]) #k
# NA l.mus
sum(is.na(biph4.model$l.mu))/length(biph4.model$l.mu) # percent negatives
# NAs are after
biph4.model$l.mu[,1:10] # first 10 individuals

```
### Sample g, par, lb.mu, sig.l

```{r samp 1}
# configure..
biph4.confmcmc <- configureMCMC(biph4.model, monitors = c("g","par","lb.mu","sig.l"))

# and build MCMC
biph4.mcmc <- buildMCMC(biph4.confmcmc)

# compile model
biph4.c <- compileNimble(biph4.model)

# compile mcmc (and specify the project model)
biph4.mcmcc <- compileNimble(biph4.mcmc)

# MCMC Samples
biph4.samp <- runMCMC(biph4.mcmcc, niter = 20000, nburnin = 15000, nchains = 2, samplesAsCodaMCMC = TRUE)

```

### Sample l.mu
```{r samp 2}
# configure..
biph4.confmcmc <- configureMCMC(biph4.model, monitors = c("l.mu"))

# and build MCMC
biph4.mcmc.lmu <- buildMCMC(biph4.confmcmc)

# compile model
biph4.c <- compileNimble(biph4.model)

# compile mcmc (and specify the project model)
biph4.mcmcc.lmu <- compileNimble(biph4.mcmc.lmu)

# MCMC Samples
biph4.samp.lmu <- runMCMC(biph4.mcmcc.lmu, niter = 15000, nburnin = 10000, nchains = 2, samplesAsCodaMCMC = TRUE)

```

### Check g, par, lb.mu, sig.l
```{r check pars}
samp <- biph4.samp
sum <- summary(samp)

# summary of values of sampled parameters
vars_subset <- grep("^g\\[", rownames(sum$statistics), value = TRUE)
summary(exp(sum$statistics[which(rownames(sum$statistics)%in%vars_subset),][,1]))
vars_subset <- grep("^par\\[", rownames(sum$statistics), value = TRUE)
vars_subset1 <- grep("1]", vars_subset, value = TRUE)
summary(exp(sum$statistics[which(rownames(sum$statistics)%in%vars_subset1),][,1]))
vars_subset2 <- grep("2]", vars_subset, value = TRUE)
summary(exp(sum$statistics[which(rownames(sum$statistics)%in%vars_subset2),][,1]))
vars_subset <- grep("^lb.mu\\[", rownames(sum$statistics), value = TRUE)
summary(sum$statistics[which(rownames(sum$statistics)%in%vars_subset),][,1])
vars_subset <- grep("sig.l", rownames(sum$statistics), value = TRUE)
sum$statistics[which(rownames(sum$statistics)%in%vars_subset),]

# some trace plots
rn <- sample(1:200, 20)
vars_subset <- grep("^g\\[", varnames(samp), value = TRUE)[rn]
traceplot(samp[, vars_subset, drop = FALSE])

vars_subset <- grep("^par\\[", varnames(samp), value = TRUE)[rn]
traceplot(samp[, vars_subset, drop = FALSE])

vars_subset <- grep("^lb.mu\\[", varnames(samp), value = TRUE)
traceplot(samp[, vars_subset, drop = FALSE])

vars_subset <- grep("sig.l", varnames(samp), value = TRUE)
traceplot(samp[, vars_subset, drop = FALSE])

```

### Plot g, par...

```{r plot pars}
# g[spat.unit, hatch.year]
samp %>%
  gather_draws(g[su, hy], sep = ",") %>%
  filter(hy == c(1:5)) %>%
  ggplot() +
  geom_density(aes(x = .value, color = factor(hy))) + # age parameter
  facet_wrap(~su, scales = "free") +
  theme_light()

# lb.mu[spat.unit]
samp %>%
  gather_draws(lb.mu[su], sep = ",") %>%
  #filter(hy == c(1:5)) %>%
  ggplot() +
  geom_density(aes(x = .value, color = factor(su))) + # age parameter
  #facet_wrap(~su, scales = "free") +
  theme_light()

# growth curves not looking ok. Should plot the individual curves and summarise the mean by su curve
samp %>%
  spread_draws(par[su,hy,p], g[su,hy], lb.mu[su], sep = ",") %>%
  mutate(g = exp(g),
         par = exp(par)) %>%
  group_by(.draw,su,p) %>%
  summarise(par.m = mean(par), g.m = mean(g), lb.mu = mean(lb.mu), .groups = "keep") %>%
  group_by(su,p) %>%
  median_qi() %>%
  mutate(p = case_when(p == 1 ~ "Linf",
                       p == 2 ~ "K",
                       .default = NA)) %>%
  pivot_wider(id_cols = su, names_from = p, values_from = c(par.m, g.m, lb.mu)) %>%
  expand_grid(age = seq(0, 12, 0.1)) %>%
  mutate(length.a = par.m_Linf*(1-exp(-par.m_K*age)),
         length.j = lb.mu_Linf + g.m_Linf) %>%
  ggplot() +
  geom_point(data = sallaa %>% filter(!age.type == "sea.only"), 
             aes(tot.age, length_mm), alpha = 0.1, color = "lightblue") +
  geom_line(aes(age, length.a, color = factor(su))) +
  geom_line(aes(age, length.j, color = factor(su))) +
  theme_light() 


```

### Check l.mu
```{r check lmu}
#samp.lmu <- biph4.samp.lmu
# remove NA nodes (the older-than-catch-age nodes)
cm <- lapply(biph4.samp.lmu, as.matrix)
nonNA_nodes <- cm %>% 
  map(~ colnames(.x)[colSums(is.na(.x)) == 0]) %>%
  reduce(intersect) # applies function intersect over elements of the lists returned by map(), i.e. removing the colnames from both lists.
cm_cleaned <- lapply(cm, function(x) x[, nonNA_nodes, drop = FALSE])
samp.cl <- mcmc.list(lapply(cm_cleaned, mcmc))  

#sum <- summary(samp.cl) # not working when l.mu == NA

# some traces of l.mu
vars_subset <- grep("^l.mu\\[", varnames(samp.cl), value = TRUE)[rn]
traceplot(samp.cl[, vars_subset, drop = FALSE])

```

### Plot predicted vs observed l.mu

```{r }
# plot observed against predicted
obs <- data %>%
  select(length_mm,tot.age,ind.id) %>%
  mutate(tot.age = round(tot.age),
         observed = length_mm)

predi <- samp.cl %>%
  gather_draws(l.mu[age,ind.id], sep = ",") %>%
  median_qi() %>%
  rename(predicted = .value) %>%
  mutate(tot.age = age-1) %>%
  filter(tot.age %in% obs$tot.age & ind.id %in% obs$ind.id)

predi %>%
  left_join(obs, by = join_by(tot.age, ind.id)) %>%
  ggplot(aes(x = observed, y = predicted)) +
  geom_point(size = 2, alpha = 0.7) +
  #geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2, alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme_minimal()

# smolt ages
# data %>%
#   filter(!is.na(smo.age)) %>%
#   select(smo.age) %>%
#   mutate(t= "obs") %>%
#   bind_rows( samp.cl %>% gather_draws(smo.age[i]) %>% rename(smo.age = .value) %>% mutate(t="pred") ) %>%
#   ggplot() +
#   geom_density(aes(smo.age, fill = t))
```


<!-- ## Biphasic 5 -->

<!-- Assuimg individuals are born May 1.  -->
<!-- Spatiotemporal model for g and par. -->

<!-- ```{r} -->

<!-- biph5.code <- nimbleCode({ -->

<!--   # likelihood -->
<!--   for(i in 1:nobs){ -->
<!--     length_mm[i] ~ dnorm(l.mu[age.index[i], ind.id[i]], sd = sig.l) -->
<!--     } -->

<!--   # Estimate length at age for each individual (j in nn) and for each age of j (k in age.index=1 to age.index[j], i.e. age 0 to catch age) -->
<!--   for(j in 1:nn){ -->
<!--     l.mu[1,j] <- lb.mu[spat.unit[j]] # hatch length and growth in the first year -->

<!--     for(k in 2:age.index[j]+1){ -->
<!--     #Say that we for hatch.year=2010 want to predict length of an individual of age 3. If we then want to use environmental conditions in 2012 to predict length in 2013, year should be hatch.year + 2 = 2012 but here k = age + 1 = 4. Using k, we need hatch.year + k - 2. BUT, this makes for using hatch year for both k=1 (in l.mu[1,j]) and k=2. Furtherm. k-1 has different meaning in the step for smolt age. -->
<!--     l.mu[k,j] <- l.mu[k-1,j] + step(smo.age[j] - (k-1))*exp(g[spat.unit[j], (hatch.year.f[j]+k-2)]) + -->
<!--       (1-step(smo.age[j] - (k-1)))*((par[spat.unit[j],(hatch.year.f[j]+k-2),1] - l.mu[k-1,j])*(1 - exp(-exp(par[spat.unit[j],(hatch.year.f[j]+k-2),2]) #*(1 + (tot.age[j] %% 1)) -->
<!--       ))) -->
<!--     } -->
<!--   } -->

<!--   # estimate smo.age.  -->
<!--   for(l in 1:nn){ -->
<!--     smo.age[l] ~ dgamma(shape = sh.sm[spat.unit[l]], scale = sc.sm) # change to DISCRETE distr. -->
<!--     } -->

<!--   # Priors   -->
<!--   sig.l ~ dexp(1/500) -->
<!--   #lb.mu ~ dnorm(17, sd = 5) # ~15 to 20 mm, https://doi.org/10.1111/j.1095-8649.2009.02497.x sd arbitary/guesstimate -->

<!--   # LKJ prior on correlation matrix, see NIMBLE manual p45. -->
<!--   Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3 -->
<!--   U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars]) -->

<!--   # priors for smolt age and juvenile growth rate -->

<!--   sc.sm <- 0.5^2/2.5 # shape = 2.5^2/.5^2 = 25, #From mean=shape*scale, var=shape*scale^2 -> shape = mean^2/var & scale = var/mean. mean=2.5, sd=0.5. -->

<!--   for(i in 1:nsu){ -->
<!--     sh.sm[i] ~ dnorm(25, sd = 5) # dgamma shape param, sd is arbitrary -->
<!--     lb.mu[i] ~ dnorm(100, sd = 25) # FIX prior -->
<!--     for(j in minyear:maxyear){ # Take into accuount hatch.year[j]+k-1 -->
<!--       par[i,j,1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0) -->
<!--       #g[i,j] ~ dnorm(0, sd = 5) # LOG SCALE and weak prior -->
<!--       g[i,j] ~ dnorm(mean = g_lmean, sd = g_lsd) # LOG SCALE and weak prior -->
<!--     } -->
<!--   } -->

<!--   g_lsd <- sqrt(log(1 + (10^2) / (50^2))) # sqrt of variance -->
<!--   g_lmean <- log(50) - 0.5 * g_lsd^2   -->

<!--   mu_par[1] ~ dnorm(1378, sd = 2*139) # Linf from fb -->
<!--   mu_par[2] ~ dnorm(mean = k_lmean, sd = k_lsd) -->
<!--   sig_par[1] ~ dlnorm(log(250),1) -->
<!--   sig_par[2] ~ dlnorm(log(0.50),1) -->

<!--   # K from fb, on log scale  -->
<!--   k_lsd <- sqrt(log(1 + (0.28^2) / (0.43^2))) # sqrt of variance -->
<!--   k_lmean <- log(0.43) - 0.5 * k_lsd^2   -->

<!--   }) -->

<!-- # Function creating the Cholesky of the covar. matrix (p45 Nimble manual) -->
<!-- uppertri_mult_diag <- nimbleFunction( -->
<!--   run = function(mat = double(2), vec = double(1)) { -->
<!--     returnType(double(2)) -->
<!--     p <- length(vec) -->
<!--     out <- matrix(nrow = p, ncol = p, init = FALSE) -->
<!--     for(k in 1:p) -->
<!--       out[ , k] <- mat[ , k] * vec[k] -->
<!--     return(out) -->
<!--    # turn off buildDerivs for the i index -->
<!-- }, buildDerivs = list(run = list(ignore = c('k')))) -->

<!-- data <- sallaa %>% -->
<!--   filter(!is.na(juv.age), -->
<!--          !is.na(year), -->
<!--          year > 2000 -->
<!--          ) %>%  -->
<!--   slice_sample(n = 5000) %>% -->
<!--   mutate(smo.age = if_else(age.type == "both", juv.age, NA), -->
<!--          sea.age = if_else(is.na(sea.age), 0, sea.age), -->
<!--          #tot.age = juv.age + sea.age, -->
<!--          age.index = as.integer(tot.age + 1), # index for l.mu, + 1 to include age 0 individuals, add 0.1 to test "tot.age %% 1" -->
<!--          hatch.year = year-tot.age, -->
<!--          hatch.year.f = as.numeric(factor(hatch.year, levels = sort(unique(hatch.year)), labels = seq_along(sort(unique(hatch.year))))), -->
<!--          year.f = as.integer(factor(year)), -->
<!--          spat.unit = as.integer(factor(spat.unit))) %>% -->
<!--   select(smo.age, tot.age, length_mm, age.index, year, spat.unit, hatch.year, hatch.year.f) %>% -->
<!--   mutate(ind.id = row_number()) # ind id -->

<!-- npars <- 2 -->
<!-- # get max year by, needed as hatch.year is integer and the last year is not (simpler solution?).   -->
<!-- maxyear <- max(data$hatch.year.f) + data %>%  -->
<!--   filter(year == max(year)) %>%  -->
<!--   filter(tot.age == max(tot.age)) %>%  -->
<!--   distinct(tot.age) %>% pull(tot.age)  -->

<!-- # build model -->
<!-- biph5.model <- nimbleModel(biph5.code, -->
<!--                            constants = list(npars = npars, -->
<!--                                              nobs = nrow(data), -->
<!--                                              nn = nrow(data), # change when >1 sample per ind.id -->
<!--                                              nsu = length(unique(data$spat.unit)), -->
<!--                                              age.index = data$age.index,  -->
<!--                                              ind.id = data$ind.id, -->
<!--                                              hatch.year.f = data$hatch.year.f, -->
<!--                                              minyear = min(data$hatch.year.f), -->
<!--                                              maxyear = maxyear, -->
<!--                                              spat.unit = data$spat.unit), -->
<!--                            data = data %>% select(-ind.id,-age.index,-spat.unit,-hatch.year,-tot.age, -year, -hatch.year.f)) -->

<!-- # check values  -->
<!-- biph5.model$simulate("sig.l") -->
<!-- biph5.model$simulate("mu_par") -->
<!-- biph5.model$simulate("sig_par") -->
<!-- biph5.model$simulate("Ustar") -->
<!-- biph5.model$simulate("U") -->
<!-- biph5.model$simulate("sh.sm") -->
<!-- biph5.model$simulate("smo.age") -->
<!-- biph5.model$simulate("lb.mu") -->
<!-- biph5.model$simulate("g") -->
<!-- biph5.model$simulate("par") -->
<!-- biph5.model$simulate("l.mu") -->

<!-- biph5.model$sig.l -->
<!-- biph5.model$U -->
<!-- biph5.model$Ustar -->
<!-- biph5.model$mu_par -->
<!-- biph5.model$sig_par -->
<!-- biph5.model$sh.sm -->
<!-- biph5.model$smo.age -->
<!-- biph5.model$lb.mu -->
<!-- exp(biph5.model$g) -->
<!-- biph5.model$par[1:11,1:25,1] -->
<!-- exp(biph5.model$par[1:11,1:20,2]) -->
<!-- # Negative l.mus -->
<!-- sum(is.na(biph5.model$l.mu))/length(biph5.model$l.mu) # percent negatives -->
<!-- # NAs are after -->
<!-- biph5.model$l.mu[,1:100] # for one age index -->

<!-- ``` -->