---
title: "Salmon Biphasic model v1"
author: "Viktor Thunell" 
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    code-fold: true
    code-summary: "Show code"
    page-layout: full
    embed-resources: true
    toc: true
knitr: 
  opts_chunk:
    fig.align: center
    out-width: 80%
editor: source
execute: 
  echo: true
  eval: true
  cache: true
---

## Load libraries

```{r libs}
#| message: false
#| warning: false
#| cache: false

# Load libraries, install if needed
pkgs <- c("tidyverse", "tidylog", "devtools","viridis","nls.multstart", "broom", "patchwork", "coda", "boot", "tidybayes","bayesplot", "nimbleHMC", "here")

# remotes::install_github("nimble-dev/nimble", ref = "devel", subdir = "packages/nimble")

if(length(setdiff(pkgs,rownames(installed.packages()))) > 0){
    install.packages(setdiff(pkgs, rownames(installed.packages())), dependencies = T)
  }

invisible(lapply(pkgs, library, character.only = T))

options(ggplot2.continuous.colour = "viridis")
theme_set(theme_light()) # check why global theme option not working when rendering
# Set path
color_scheme_set("viridis")
home <- here::here()
```

## Read data

```{r}
#| message: false
#| warning: false
#| cache: false

sallaa.all <- readRDS(file = paste0(home,"/data/data-for-2-2/salmon-laa_2025-06-19.RData")) %>%
  rename(year = fi_year,
         site = sai_location,
         sea.age = sea_age_year,
         juv.age = juvenile_age_year,
         #tot.age = tot_age_year, #wrong
         lat = fisa_y_4326,
         lon = fisa_x_4326) %>%
  #filter out non-aged individuals (~34000 individuals)
  filter(!(is.na(sea.age) & is.na(juv.age)))

```

For now I will use the "both" type only.

```{r}
# Create a new dataset 
sallaa <- sallaa.all #%>%
  # filter out age type "both" 
  #filter(age.type == "both")

sallaa %>%
  drop_na(sex) %>%
  ggplot(aes(juv.age+sea.age, length_mm, color = sex)) +
  geom_point() +
  facet_grid(age.type~sex) +
  scale_x_continuous(breaks = seq(0, 13, 1) ) +
  theme_light() 

```

# Hists of age and length

CORRECT TOT AGE!!
```{r}

# If dropping all inds where both sea and sm age is NA
sallaa %>% 
  ggplot() +
  geom_density(aes(x = juv.age+sea.age), fill = "deeppink", alpha = 0.5) +
  xlim(0, 13) +

sallaa %>% 
  ggplot() + 
  geom_density(aes(x = length_mm), fill = "deeppink", alpha = 0.5)

sallaa %>% 
  ggplot() +
  geom_density(aes(x = length_mm, fill = factor(sea.age)), alpha = 0.5) +
  #geom_histogram(aes(x = length)) +
  facet_wrap(~juv.age+sea.age, scales = "free")

sallaa %>% 
  filter(.age == 0) %>%
  ggplot() +
  geom_density(aes(x = length_mm, fill = factor(juv.age+sea.age)), alpha = 0.5)

# age at smolification
sallaa %>% 
  ggplot() +
  geom_density(aes(x = juv.age, color = spat.unit),  alpha = 0.5) +
  facet_wrap(~spat.unit) +
  xlim(-1, 5) 

sallaa %>%
  filter(age.type == "juve.only") %>%
  ggplot(aes(x = juv.age, y =length_mm, color = spat.unit)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = lm) +
  facet_wrap(~spat.unit)

```



### Biphasic 0

using vb params directly instead of formulatng them using h, T, t1 and g 

```{r}

biph0.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    length_mm[i] ~ dnorm(mu[i], sd = sig.l)
    
    # Assuming T = A50 (age at 50 smoltification) and disregarding g (cost of maturity)
    # when pre.smo == 0, adult growth becomes 0 removing need for if-else
    # t0 is vb adult, and t1 immature, age at length 0, see eq. 2 in Wilson et al.
    # mu[i] <- (h*(juv.age[i]-t1))*pre.smo[i] +
    #   par[1]*(1-exp(-exp(par[2])*((smo.age[i]+sea.age[i])-par[3])))*post.smo[i]
    
    muj[i] <- h*(juv.age[i]-t1)
    mua[i] <- par[1]*(1-exp(-exp(par[2])*((smo.age[i]+sea.age[i])-par[3])))

    # Juvenile part active when first[i] < SY[i]
    # mu.pred[i, first[i]] <- muR1[i] * (1 - step(smo.age[i]+sea.age[i] - smo.age[i])) +
    #                         muL1[i] * step(smo.age[i]+sea.age[i] - smo.age[i])
    mu[i] <- muj[i]*(1 - step(sea.age[i] - 0.01)) + mua[i]*step(sea.age[i] - 0.01)
  }
  
  # estimate juv.age. gamma w mu = ~2 years and sd = 0.5. shape = (mean / sd)^2 and rate = shape/mean -> rate=8 and shape 16.
  for(k in 1:nobs){
    juv.age[k] ~ dgamma(mean = 2, sd = 0.5)
  }
  
  # estimate T. gamma w mu = ~2.5 years and sd = 0.5. shape = (mean / sd)^2 and rate = shape/mean 
  for(j in 1:nobs){
    smo.age[j] ~ dgamma(mean = 2.5, sd = 0.5)
  }

  # # Predictions for specified prediction ages
  # for(k in 1:npred) {
  #   pred_length[k] <- (h*(age.pred[k]-t1)) + par[1]*(1-exp(-(par[2])*(age.pred[k]))) 
  # }
  
  # Priors  
  sig.l ~ dexp(1/500)
  
  # # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars])

  par[1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
  
   h ~ dlnorm(0, 1)
   t1 ~ dnorm(-5,5)
   
   mu_par[1] ~ dnorm(1378, sd = 2*139) # Linf from fb
   mu_par[2] ~ dnorm(log(0.43), sd = 0.28) # K from fb
   mu_par[3] ~ dnorm(-0.4, sd = 0.2)  # t0 from fb
   sig_par[1] ~ dlnorm(log(250),1)
   sig_par[2] ~ dlnorm(log(0.50),1)
   sig_par[3] ~ dlnorm(log(0.2),1)
    
    })

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k'))))

data <- sallaa %>%
  mutate(# juvenile age cant be zero
         juv.age = if_else(juv.age == 0, juv.age+0.5, juv.age),
         # define smolt age for post-smolt individuals. NAs are estimated in the model
         smo.age = if_else(is.na(sea.age), NA, juv.age),
         # make logical stage identifier for mu
         pre.smo = if_else(is.na(sea.age), 1, 0),
         post.smo = if_else(!is.na(sea.age), 1, 0),
         # sea age cant be zero if they are post smolts
         sea.age = if_else(sea.age == 0 & !is.na(sea.age), sea.age+0.5, sea.age),
         # turn the juveniles sea age to zero
         sea.age = if_else(is.na(sea.age), 0, sea.age),
         )

# data %>%
#   distinct(sea.age,juv.age,smo.age)

npars <- 3

#data.list <- data %>% select(juv.age,sea.age,smo.age,length_mm) %>% as.list()
data.list <- data %>% select(pre.smo,post.smo,juv.age,sea.age,smo.age,length_mm) %>% as.list()
# # age for predictions
# data.list$age.pred <- seq(0.1, 12, by = 0.1)

# build model
biph0.model <- nimbleModel(biph0.code,
                        constants = list(npars = npars,
                                         nobs = nrow(data)
                                         #npred = length(data.list$age.pred)
                                         ),
                        #inits=inits(),
                        data = data.list)#,
                        #buildDerivs = TRUE)

```

Ã¤.#### Fixing checks

```{r}
#biph0.model$initializeInfo()
biph0.model$simulate("sig.l")
biph0.model$simulate("mu_par")
biph0.model$simulate("sig_par")
biph0.model$simulate("Ustar")
biph0.model$simulate("U")
biph0.model$simulate("par")
biph0.model$simulate("h")
biph0.model$simulate("t1")
biph0.model$sig.l
biph0.model$U
biph0.model$Ustar
biph0.model$mu_par
biph0.model$sig_par
biph0.model$t1
biph0.model$h
biph0.model$par
exp(biph0.model$par[2])
biph0.model$simulate("juv.age")
biph0.model$juv.age
biph0.model$simulate("smo.age")
biph0.model$smo.age
biph0.model$simulate("muj")
biph0.model$simulate("mua")
biph0.model$muj[1:10]
biph0.model$mua[1:10]
biph0.model$simulate("mu")
biph0.model$mu
sum(is.na(biph0.model$mu))
data[which(biph0.model$mu < 0),]
mean(biph0.model$smo.age) - mean(biph0.model$juv.age)
```

#### Configure, Build & Compile model & HMC

```{r}
# configure hmc
# biph0.confhmc <- configureHMC(biph0.model, 
#                                monitors = c("h", "t1", "par")) 
biph0.confmcmc <- configureMCMC(biph0.model, 
                                 monitors = c("h", "t1", "par")) 

# build mcmc (use buidlHMC() when not using configureHMC())
#biph0.hmc <- buildMCMC(biph0.confhmc)
biph0.mcmc <- buildMCMC(biph0.confmcmc)

# compile model
biph0.c <- compileNimble(biph0.model)

# compile mcmc and specify the project model
#biph0.hmcc <- compileNimble(biph0.hmc)
biph0.mcmcc <- compileNimble(biph0.mcmc)

#### HMC Samples
#help(NUTS)

#biph0.samp <- runMCMC(biph0.hmcc, niter = 500, nburnin = 300, nchains = 2, samplesAsCodaMCMC = TRUE)
biph0.samp2 <- runMCMC(biph0.mcmcc, niter = 50000, nburnin = 40000, nchains = 2, samplesAsCodaMCMC = TRUE)

```

```{r}
summary(biph0.samp2)
sam <- biph0.samp2

mcmc_trace(biph0.samp2)

sam %>%
  spread_draws(h,t1) %>% 
  median_qi() %>%
  bind_cols(sam %>% spread_draws(par[i]) %>% median_qi() )
  mutate(if_else(i == 1, mu))
  ggplot() +
  geom_line(aes(x = i/10, y = pred_length)) +
  geom_ribbon(aes(x = i/10, y = pred_length, ymin = .lower, ymax = .upper), alpha = .2, fill = "red") +
  geom_point(data = data, aes(juv.age+sea.age, length_mm)) +
  scale_x_continuous(breaks = seq(0, 13, 1) )

# as.data.frame(biph0.samp) %>%
#   summarise(across(starts_with("pred_length["), 
#                    list(mean = mean, 
#                         lwr = ~quantile(.x, 0.025),
#                         upr = ~quantile(.x, 0.975)))) %>%
#   pivot_longer(cols = everything(),
#                names_to = c("pred", ".value"),
#                names_pattern = "pred_length\\[(\\d+)\\]_(.*)") %>%
#   mutate(pred = as.integer(pred),
#          age_pred = age_pred_data[pred])
# 
# preds %>%
#   ggplot() +
#   geom_line(aes(x = age, y = length)) +
#   geom_ribbon(aes(x = age,y = length, ymin = length.lo, ymax = length.up), alpha = .2, fill = "red") +
#  geom_point(data = sallaa2, aes(age.tot, length)) +
#   scale_x_continuous(breaks = seq(0, 13, 1) )

biph0.samp2 %>%
  gather_draws(par[np], h,t1) %>%
  median_qi() %>%
  mutate(par = case_when(np == 1 ~ "Linf",
                         np == 2 ~ "K",
                         np == 3 ~ "t0",
                         .default = .variable),
         .value = case_when(par == "K" ~ exp(.value), .default = .value)) %>%
  select(par, .value) %>%
  pivot_wider(names_from = par, values_from = .value) %>%
  expand_grid(age = seq(0, 12, 0.1)) %>%
  mutate(length.a = Linf*(1-exp(-K*(age-t0))),
         length.j = t1 + age*h) %>%
  ggplot() +
  geom_point(data = sallaa %>% 
               filter(!age.type == "sea.only", !is.na(juv.age)) %>% 
               mutate(sea.age = if_else(is.na(sea.age), 0, sea.age), 
                      tot.age = juv.age+sea.age), 
             aes(x = tot.age, y = length_mm), alpha = 0.1, color = "lightblue") +
  geom_line(aes(age, length.a)) +
  geom_line(aes(age, length.j), color = "red")  +
  ylim(0, 1500) +
  theme_light() 


```

### Uniphasic fabens

using vb params directly and fabens vb. 

```{r}

biph1.code <- nimbleCode({
  
  # likelihood
    for(i in 1:nobs){
      length.mu2[i] ~ dnorm(mu[i], sd = sig.l)
      
      mu[i] <- length.mu1[i] + (par[1] - length.mu1[i]) * (1 - exp(-exp(par[2])))
        
      }  

  # Priors  
  sig.l ~ dexp(1/500)
  
  # # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars])

  par[1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
  
   mu_par[1] ~ dnorm(1378, sd = 2*139) # Linf from fb
   mu_par[2] ~ dnorm(log(0.43), sd = 0.28) # K from fb
   sig_par[1] ~ dlnorm(log(250),1)
   sig_par[2] ~ dlnorm(log(0.50),1)
    
    })

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k'))))

data <- sallaa %>%
  filter(!is.na(juv.age),
         !is.na(sea.age),
         age.type == "both"
         #!sea.age == 0
         #!juv.age == 0
         ) %>%
  mutate(tot.age = juv.age + sea.age) %>%
  mutate(length.mu = mean(length_mm), .by = tot.age) %>%
  distinct(tot.age, length.mu) %>%
  mutate(length.mu1 = length.mu,
         length.mu2 = lag(length.mu1, order_by = tot.age, default = 0))

npars <- 2

# build model
biph1.model <- nimbleModel(biph1.code,
                        constants = list(npars = npars,
                                         nobs = nrow(data)),
                        data = data,
                        buildDerivs = TRUE)

```

```{r}
#biph1.model$initializeInfo()
biph1.model$simulate("sig.l")
biph1.model$simulate("mu_par")
biph1.model$simulate("sig_par")
biph1.model$simulate("Ustar")
biph1.model$simulate("U")
biph1.model$simulate("par")
biph1.model$sig.l
biph1.model$U
biph1.model$Ustar
biph1.model$mu_par
biph1.model$sig_par
biph1.model$par
exp(biph1.model$par[2])
biph1.model$simulate("mu")
biph1.model$mu
```

#### Configure, Build & Compile model & HMC

```{r}
# configure hmc
# biph0.confhmc <- configureHMC(biph0.model, 
#                                monitors = c("h", "t1", "par")) 
biph1.confmcmc <- configureMCMC(biph1.model, 
                                 monitors = c("mu", "par")) 

# build mcmc (use buidlHMC() when not using configureHMC())
#biph0.hmc <- buildMCMC(biph0.confhmc)
biph1.mcmc <- buildMCMC(biph1.confmcmc)

# compile model
biph1.c <- compileNimble(biph1.model)

# compile mcmc and specify the project model
#biph0.hmcc <- compileNimble(biph0.hmc)
biph1.mcmcc <- compileNimble(biph1.mcmc)

#### HMC Samples
#help(NUTS)

#biph0.samp <- runMCMC(biph0.hmcc, niter = 500, nburnin = 300, nchains = 2, samplesAsCodaMCMC = TRUE)
biph1.samp <- runMCMC(biph1.mcmcc, niter = 10000, nburnin = 7000, nchains = 2, samplesAsCodaMCMC = TRUE)

```
```{r}
summary(biph1.samp)

mcmc_trace(biph1.samp)

biph1.samp %>%
  gather_draws(par[np]) %>%
  median_qi() %>%
  mutate(par = case_when(np == 1 ~ "Linf",
                         np == 2 ~ "K"),
         .value = case_when(par == "K" ~ exp(.value), .default = .value)) %>%
  select(par, .value) %>%
  pivot_wider(names_from = par, values_from = .value) %>%
  expand_grid(age = seq(0, 12, 1)) %>%
  mutate(length = Linf*(1-exp(-K*age))) %>%
  ggplot() +
  geom_point(data = sallaa %>% 
               filter(!age.type == "sea.only", !is.na(juv.age)) %>% 
               mutate(sea.age = if_else(is.na(sea.age), 0, sea.age), 
                      tot.age = juv.age+sea.age), 
             aes(x = tot.age, y = length_mm), alpha = 0.1, color = "lightblue") +
  geom_line(aes(age, length)) +
  theme_light() 
  
```

### Biphasic 1.5

IN this case I will use only data on individuals with discrete ages, i.e. disregarding estimated ages and 0+ pre and post smolts (i.e. juv-age == 0  and sea.age == 0). Then I can estimate length increments between ages. The length at T-1 and the length increment is then estimated. But what are my observations?

Observations are used in estimating a mean length at age

add to data:
- cohort (birth year)
- make age a factor?

Estimate
- mean length of individuals by (cohort) and year (done in data)
- 
```{r}

biph15.code <- nimbleCode({
  
  # likelihood
  
  # estimate length at age
  for(i in minage+1:maxage-1){

    length.mu2[i] ~ dnorm(mu[i], sd = sig.l)
    
    muj[i] <- mu0 + h[i]
    mua[i] <- length.mu1[i] + (par[1] - length.mu1[i]) * (1 - exp(-exp(par[2])))
    mu[i] <- muj[i]*(1 - step(sea.age[i] - 0.01)) + mua[i]*step(sea.age[i] - 0.01)

  }
  
  # estimate length at age = 0 
  for(j in 1:id0_n){
    
    muz[j] ~ dnorm(mean = mub[j], sd = 1)
    mub[j] <- length_mm[id0[j]]

  }
 
  # estimate length at smolt age
  for(j in 1:ids_n){
    
    mus[j] ~ dnorm(mean = muc[j], sd = 1)
    muc[j] <- length_mm[ids[j]]
                        
  }
  
  # Priors  
  sig.l ~ dexp(1/500)
  
  # # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars])

  par[1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
  
  mu_par[1] ~ dnorm(1378, sd = 2*139) # Linf from fb
   mu_par[2] ~ dnorm(log(0.43), sd = 0.28) # K from fb
   sig_par[1] ~ dlnorm(log(250),1)
   sig_par[2] ~ dlnorm(log(0.50),1)
  
  musd <- 50
  h[1] ~ dnorm(musd, sd = musd)
  h[2] ~ dnorm(musd, sd = musd)
  h[3] ~ dnorm(musd, sd = musd)
  h[4] ~ dnorm(musd, sd = musd)
  h[5] ~ dnorm(musd, sd = musd)
  h[6] ~ dnorm(musd, sd = musd)
  h[7] ~ dnorm(musd, sd = musd)
  h[8] ~ dnorm(musd, sd = musd)
  h[9] ~ dnorm(musd, sd = musd)
  h[10] ~ dnorm(musd, sd = musd)
  h[11] ~ dnorm(musd, sd = musd)
  h[12] ~ dnorm(musd, sd = musd)
  
  mu0 ~ dnorm(0, sd = 1)
  
  })

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k'))))

data1 <- sallaa %>% 
  filter(age.type %in% c("both","juve.only")) %>%
  mutate(sea.age = if_else(is.na(sea.age), 0, sea.age)) %>%
  select(length_mm, sea.age, juv.age, age.type) 

data2 <- data1 %>% 
  mutate(tot.age = juv.age + sea.age) %>%
  arrange(tot.age) %>%
  mutate(length.mu1 = mean(length_mm), .by = c(tot.age, age.type)) %>%
  distinct(tot.age, length.mu1, sea.age, juv.age) %>%
  as.list()


id0 <- which(data1$juv.age == min(data1$juv.age))
id0_n <- length(id0)
ids <- which(data1$sea.age == min(data1$sea.age))
ids_n <- length(ids)
minage <- min(data2$juv.age)
maxage <- max(data2$tot.age)
npars <- 2

data2$length_mm <- data1$length_mm

# build model
biph15.model <- nimbleModel(biph15.code,
                            constants = list(npars = npars,
                                             id0_n = id0_n,
                                             id0 = id0,
                                             ids = ids,
                                             ids_n = ids_n,
                                             minage = minage,
                                             maxage = maxage
                                             ),
                            data = data2)

```

#### Fixing checks

```{r}
biph15.model$initializeInfo()
biph15.model$simulate("sig.l")
biph15.model$simulate("mu_par")
biph15.model$simulate("sig_par")
biph15.model$simulate("Ustar")
biph15.model$simulate("U")
biph15.model$simulate("par")
biph15.model$simulate("h")
biph15.model$simulate("mu0")
biph15.model$simulate("mub")
biph15.model$simulate("muz")
biph15.model$sig.l
biph15.model$U
biph15.model$Ustar
biph15.model$mu_par
biph15.model$sig_par
biph15.model$mu0
biph15.model$h
biph15.model$par
exp(biph15.model$par[2])
biph15.model$simulate("mua")
biph15.model$simulate("muj")
biph15.model$muj
biph15.model$mua
biph15.model$mub
biph15.model$muz
biph15.model$mu0
biph15.model$simulate("mu")
biph15.model$mu

```

#### Configure, Build & Compile model
```{r}
# configure hmc
# biph0.confhmc <- configureHMC(biph0.model, 
#                                monitors = c("h", "t1", "par")) 
biph15.confmcmc <- configureMCMC(biph15.model,
                                 monitors = c("h", "par","mu", "muj", "mua","mu0"))

# build mcmc (use buidlHMC() when not using configureHMC())
#biph0.hmc <- buildMCMC(biph0.confhmc)
biph15.mcmc <- buildMCMC(biph15.confmcmc)

# compile model
biph15.c <- compileNimble(biph15.model)

# compile mcmc and specify the project model
#biph0.hmcc <- compileNimble(biph0.hmc)
biph15.mcmcc <- compileNimble(biph15.mcmc)

#### HMC Samples
#help(NUTS)

#biph0.samp <- runMCMC(biph0.hmcc, niter = 500, nburnin = 300, nchains = 2, samplesAsCodaMCMC = TRUE)
biph15.samp <- runMCMC(biph15.mcmcc, niter = 20000, nburnin = 10000, nchains = 2, samplesAsCodaMCMC = TRUE)


```

```{r}
summary(biph15.samp)

mcmc_trace(biph15.samp)

biph15.samp %>%
  gather_draws(par[np], h[age], mu0) %>%
  median_qi() %>%
  mutate(par = case_when(np == 1 ~ "Linf",
                         np == 2 ~ "K",
                         .variable == "h" ~ "h",
                         .default = NA),
         .value = case_when(par == "K" ~ exp(.value), .default = .value)) %>%
  select(par, .value) %>%
  pivot_wider(names_from = par, values_from = .value) %>%
  expand_grid(age = seq(0, 12, 0.1)) %>%
  mutate(length.a = Linf*(1-exp(-K*age)),
         length.j = mu0 + h) %>%
  ggplot() +
  #geom_point(sallaa %>% filter(!age.type == "sea.only", !is.na(sea.age), !is.na(juv.age)), 
   #          aes(juv.age+sea.age, length_mm), alpha = 0.1, color = "lightblue") +
  geom_line(aes(age, length.a)) +
  geom_line(aes(age, length.j)) +
  theme_light() 
```


### Biphasic 2

```{r}

biph2.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    length_mm[i] ~ dnorm(l.mu[tot.age[i], ind.id[i]], sd = sig.l) # tot.age = 0 cant be an index, so start at 1????
    }
  
  # estimate length at age
  for(j in 1:nn){ # for each individual
    l.mu[1,j] <- l0.mu + g

    for(k in 2:(maxage)){ # k=2 age 1, and when smo.age==1, 
    l.mu[k,j] <-  l.mu[k-1,j] + step(smo.age[j] - k)*g + 
      (1-step(smo.age[j] - k))*((par[1] - l.mu[k-1,j]) * (1 - exp(-exp(par[2]))))
    }
  }
  
  # Priors  
  sig.l ~ dexp(1/500)
  l0.mu ~ dnorm(100, sd = 1) # length at birth check literature 
  g ~ dnorm(0, sd = 1)  
  
  # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars])

  par[1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
  
  mu_par[1] ~ dnorm(1378, sd = 2*139) # Linf from fb
  mu_par[2] ~ dnorm(log(0.43), sd = 0.28) # K from fb
  sig_par[1] ~ dlnorm(log(250),1)
  sig_par[2] ~ dlnorm(log(0.50),1)
  
  })

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k'))))

data <- sallaa %>%
  filter(!is.na(juv.age)) %>%
  mutate(smo.age = juv.age,
         #smo.age = if_else(age.type == "both", juv.age, NA),
         sea.age = if_else(is.na(sea.age), 0, sea.age),
         tot.age = juv.age + sea.age,
         ) %>%
  select(smo.age,tot.age,length_mm) %>%
  filter(tot.age > 0) %>%
  slice_sample(n = 1500) %>%
  mutate(ind.id = row_number()) # ind id

  npars <- 2

# build model
biph2.model <- nimbleModel(biph2.code,
                           constants = list(npars = npars,
                                            nobs = nrow(data),
                                            nn = nrow(data), # change when having >1 sample per fish!!
                                            tot.age = data$tot.age,
                                            ind.id = data$ind.id,
                                            maxage = max(data$tot.age)),
                           data = data %>% select(-ind.id,-tot.age))

biph2.model$simulate("sig.l")
biph2.model$simulate("mu_par")
biph2.model$simulate("sig_par")
biph2.model$simulate("Ustar")
biph2.model$simulate("U")
biph2.model$simulate("par")
biph2.model$simulate("g")
biph2.model$simulate("l0.mu")
biph2.model$simulate("l.mu")
biph2.model$sig.l
biph2.model$U
biph2.model$Ustar
biph2.model$mu_par
biph2.model$sig_par
biph2.model$g
biph2.model$par
biph2.model$l0.mu
biph2.model$l.mu[1:7,1000:1010]
dim(biph2.model$l.mu)

# biph2.model$smolt.age > data$tot.age
# sum(data$smo.age > data$tot.age, na.rm= TRUE)

  #summary(data$smo.age)
  #summary(data$tot.age)
  # sallaa %>%
  # filter(age.type == "both") %>%
  #   filter(smo.age >)
  # summarise(min(juv.age)) #1  
```

#### Configure, Build & Compile model
```{r}
# configure hmc
# biph0.confhmc <- configureHMC(biph0.model, 
#                                monitors = c("h", "t1", "par")) 
biph2.confmcmc <- configureMCMC(biph2.model,
                                 monitors = c("g","par","l0.mu","l.mu"))

# build mcmc (use buidlHMC() when not using configureHMC())
biph2.mcmc <- buildMCMC(biph2.confmcmc)

# compile model
biph2.c <- compileNimble(biph2.model)

# compile mcmc and specify the project model
#biph0.hmcc <- compileNimble(biph0.hmc)
biph2.mcmcc <- compileNimble(biph2.mcmc)

#### HMC Samples
#help(NUTS)

#biph0.samp <- runMCMC(biph0.hmcc, niter = 500, nburnin = 300, nchains = 2, samplesAsCodaMCMC = TRUE)
biph2.samp <- runMCMC(biph2.mcmcc, niter = 200000, nburnin = 180000, nchains = 2, samplesAsCodaMCMC = TRUE)


```
```{r}
summary(biph2.samp)
samp <- biph2.samp

pn = 16 # number of plots in each frame
n = ncol(as.matrix(samp$chain1)) # number of nodes
# loop trace through nodes
for(i in seq(0, n, by = pn)){
  m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)
  print(mcmc_trace(samp, pars = vars(i:m)))
}

biph15.samp %>%
  gather_draws(par[np], h[age], mu0) %>%
  median_qi() %>%
  mutate(par = case_when(np == 1 ~ "Linf",
                         np == 2 ~ "K",
                         .variable == "h" ~ "h",
                         .default = NA),
         .value = case_when(par == "K" ~ exp(.value), .default = .value)) %>%
  select(par, .value) %>%
  pivot_wider(names_from = par, values_from = .value) %>%
  expand_grid(age = seq(0, 12, 0.1)) %>%
  mutate(length.a = Linf*(1-exp(-K*age)),
         length.j = mu0 + h) %>%
  ggplot() +
  #geom_point(sallaa %>% filter(!age.type == "sea.only", !is.na(sea.age), !is.na(juv.age)), 
   #          aes(juv.age+sea.age, length_mm), alpha = 0.1, color = "lightblue") +
  geom_line(aes(age, length.a)) +
  geom_line(aes(age, length.j)) +
  theme_light() 
```

### Biphasic 2.5
Replacing tot.age in lilkehood with age index and adding catch date age correction. Estimating smolt age.
```{r}

biph25.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    length_mm[i] ~ dnorm(l.mu[age.index[i], ind.id[i]], sd = sig.l) # age index is age + 1 to include data on age 0 individuals
    }
  
  # estimate length at age
  for(j in 1:nn){ # for each individual
    l.mu[1,j] <- lb.mu + g

    for(k in 2:(maxage+2)){ # add 2 to k to get max age + 1 and correct for age index
    l.mu[k,j] <-  l.mu[k-1,j] + step(smo.age[j] - k)*g + 
      (1-step(smo.age[j] - k))*((par[1] - l.mu[k-1,j]) * (1 - exp(-exp(par[2])
                                                                  *(1 + (tot.age[j] %% 1)))))
    }
  } # add remainder for maxage only! 
  
  # estimate smo.age. gamma w mu = ~2.5 makes rate = 2*shape and variance = 2/rate. With sd = 0.5, variance = 0.25,  rate=8 and shape 16.
  for(l in 1:nobs){
    smo.age[l] ~ dgamma(mean = 2.5, sd = 0.5)

    }
    
  # Priors  
  sig.l ~ dexp(1/500)
  lb.mu ~ dnorm(10, sd = 5) # length at birth check literature 
  g ~ dnorm(0, sd = 1)  
  
  # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars])

  par[1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
  
  mu_par[1] ~ dnorm(1378, sd = 2*139) # Linf from fb
  mu_par[2] ~ dnorm(log(0.43), sd = 0.28) # K from fb
  sig_par[1] ~ dlnorm(log(250),1)
  sig_par[2] ~ dlnorm(log(0.50),1)
  
  })

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k'))))

data <- sallaa %>%
  filter(!is.na(juv.age)) %>%
  mutate(#smo.age = juv.age,
         smo.age = if_else(age.type == "both", juv.age, NA),
         sea.age = if_else(is.na(sea.age), 0, sea.age),
         tot.age = juv.age + sea.age + 0.1,
         age.index = tot.age + 1 - 0.1, # index for l.mu
         ) %>%
  select(smo.age,tot.age,length_mm, age.index) %>%
  #filter(tot.age > 0) %>%
  slice_sample(n = 1500) %>%
  mutate(ind.id = row_number()) # ind id

npars <- 2

# build model
biph25.model <- nimbleModel(biph25.code,
                            constants = list(npars = npars,
                                            nobs = nrow(data),
                                            nn = nrow(data), # change when having >1 sample per fish!!
                                            #tot.age = data$tot.age,
                                            age.index = data$age.index,
                                            ind.id = data$ind.id,
                                            maxage = max(data$tot.age)),
                            data = data %>% select(-ind.id,-age.index))

biph25.model$simulate("sig.l")
biph25.model$simulate("mu_par")
biph25.model$simulate("sig_par")
biph25.model$simulate("Ustar")
biph25.model$simulate("U")
biph25.model$simulate("par")
biph25.model$simulate("g")
biph25.model$simulate("lb.mu")
biph25.model$simulate("smo.age")
biph25.model$simulate("l.mu")
biph25.model$sig.l
biph25.model$U
biph25.model$Ustar
biph25.model$mu_par
biph25.model$smo.age
biph25.model$sig_par
biph25.model$g
biph25.model$par[1]
exp(biph25.model$par[2])
biph25.model$lb.mu
biph25.model$l.mu[1:7,1000:1010]
#dim(biph25.model$l.mu)

#data$tot.age %% 1
# biph25.model$smo.age > data$tot.age #only simulated...
# sum(data$smo.age > data$tot.age, na.rm= TRUE)

  #summary(data$smo.age)
  #summary(data$tot.age)
  # sallaa %>%
  # filter(age.type == "both") %>%
  #   filter(smo.age >)
  # summarise(min(juv.age)) #1  
```

#### Configure, Build & Compile model
```{r}
# configure hmc
# biph0.confhmc <- configureHMC(biph0.model, 
#                                monitors = c("h", "t1", "par")) 
biph25.confmcmc <- configureMCMC(biph25.model,
                                 monitors = c("g","par","lb.mu","l.mu"))

# build mcmc (use buidlHMC() when not using configureHMC())
biph25.mcmc <- buildMCMC(biph25.confmcmc)

# compile model
biph25.c <- compileNimble(biph25.model)

# compile mcmc and specify the project model
#biph0.hmcc <- compileNimble(biph0.hmc)
biph25.mcmcc <- compileNimble(biph25.mcmc)

#### HMC Samples
#help(NUTS)

#biph0.samp <- runMCMC(biph0.hmcc, niter = 500, nburnin = 300, nchains = 2, samplesAsCodaMCMC = TRUE)
biph25.samp <- runMCMC(biph25.mcmcc, niter = 200000, nburnin = 180000, nchains = 2, samplesAsCodaMCMC = TRUE)


```

```{r}
#summary(biph25.samp)
samp <- biph25.samp
#as.matrix(samp$chain1)

mcmc_trace(samp, pars = vars("par[1]", "par[2]"))
mcmc_trace(samp, pars = vars("g", "lb.mu", "par[1]"))

# pn = 16 # number of plots in each frame
# n = ncol(as.matrix(samp$chain1)) # number of nodes
# # loop trace through nodes
# for(i in seq(0, n, by = pn)){
#   m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)
#   print(mcmc_trace(samp, pars = vars(i:m)))
# }
# 
# biph25.samp %>%
#   gather_draws(par[np], h[age], mu0) %>%
#   median_qi() %>%
#   mutate(par = case_when(np == 1 ~ "Linf",
#                          np == 2 ~ "K",
#                          .variable == "h" ~ "h",
#                          .default = NA),
#          .value = case_when(par == "K" ~ exp(.value), .default = .value)) %>%
#   select(par, .value) %>%
#   pivot_wider(names_from = par, values_from = .value) %>%
#   expand_grid(age = seq(0, 12, 0.1)) %>%
#   mutate(length.a = Linf*(1-exp(-K*age)),
#          length.j = mu0 + h) %>%
#   ggplot() +
#   #geom_point(sallaa %>% filter(!age.type == "sea.only", !is.na(sea.age), !is.na(juv.age)), 
#    #          aes(juv.age+sea.age, length_mm), alpha = 0.1, color = "lightblue") +
#   geom_line(aes(age, length.a)) +
#   geom_line(aes(age, length.j)) +
#   theme_light() 
```


### Biphasic 3

Spatial model for par and g
```{r}

biph3.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    length_mm[i] ~ dnorm(l.mu[age.index[i], ind.id[i]], sd = sig.l) # age index is age + 1 to include data on age 0 individuals
    }
  
  # estimate length at age
  for(j in 1:nn){ # for each individual
    l.mu[1,j] <- lb.mu + g[spat.unit[j]]

    for(k in 2:(maxage+2)){ # add 2 to k to get max age + 1 and correct for age index
    l.mu[k,j] <-  l.mu[k-1,j] + step(smo.age[j] - k)*g[spat.unit[j]] + 
      (1-step(smo.age[j] - k))*((par[spat.unit[j],1] - l.mu[k-1,j])*(1 - exp(-exp(par[spat.unit[j],2])
                                                                  #*(1 + (tot.age[j] %% 1))
                                                                  )))
    }
    }
  
  # estimate smo.age. gamma w mu = ~2.5 makes rate = 2*shape and variance = 2/rate. With sd = 0.5, variance = 0.25,  rate=8 and shape 16.
  for(l in 1:nn){
    smo.age[l] ~ dgamma(shape = s.mu[spat.unit[l]], scale = 0.5^2/2.5)
    }
    
  # Priors  
  sig.l ~ dexp(1/500)
  lb.mu ~ dnorm(10, sd = 5) # length at birth check literature 
  
  # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars])

  for(i in 1:nsu){
    par[i, 1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
    s.mu[i] ~ dnorm(16, sd = 1) # shape of dgamma
    g[i] ~ dnorm(0, sd = 1)
   
  }

  mu_par[1] ~ dnorm(1378, sd = 2*139) # Linf from fb
  mu_par[2] ~ dnorm(log(0.43), sd = 0.28) # K from fb
  sig_par[1] ~ dlnorm(log(250),1)
  sig_par[2] ~ dlnorm(log(0.50),1)
  
})

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k'))))

data <- sallaa %>%
  filter(!is.na(juv.age)) %>%
  mutate(smo.age = if_else(age.type == "both", juv.age, NA),
         sea.age = if_else(is.na(sea.age), 0, sea.age),
         tot.age = juv.age + sea.age + 0.1,
         age.index = as.integer(tot.age + 1 - 0.1), # index for l.mu
         spat.unit = as.integer(factor(spat.unit))
         ) %>%
  select(smo.age, tot.age, length_mm, age.index, spat.unit) %>%
  slice_sample(n = 1500) %>%
  mutate(ind.id = row_number()) # ind id

npars <- 2

# build model
biph3.model <- nimbleModel(biph3.code,
                            constants = list(npars = npars,
                                            nobs = nrow(data),
                                            nn = nrow(data), # change when having >1 sample per fish!!
                                            nsu = length(unique(data$spat.unit)),
                                            age.index = data$age.index,
                                            ind.id = data$ind.id,
                                            maxage = max(data$tot.age),
                                            spat.unit = data$spat.unit),
                            data = data %>% select(-ind.id,-age.index,-spat.unit))


biph3.model$simulate("sig.l")
biph3.model$simulate("mu_par")
biph3.model$simulate("sig_par")
biph3.model$simulate("Ustar")
biph3.model$simulate("U")
biph3.model$simulate("par")
biph3.model$simulate("g")
biph3.model$simulate("lb.mu")
biph3.model$simulate("s.mu")
biph3.model$simulate("smo.age")
biph3.model$simulate("l.mu")
biph3.model$sig.l
biph3.model$U
biph3.model$Ustar
biph3.model$mu_par
biph3.model$s.mu
biph3.model$smo.age
biph3.model$sig_par
biph3.model$g
biph3.model$par[,1]
exp(biph3.model$par[,2])
biph3.model$lb.mu
biph3.model$l.mu[1:10,1000:1020]

#data$tot.age %% 1
# biph25.model$smo.age > data$tot.age #only simulated...
# sum(data$smo.age > data$tot.age, na.rm= TRUE)

  #summary(data$smo.age)
  #summary(data$tot.age)
  # sallaa %>%
  # filter(age.type == "both") %>%
  #   filter(smo.age >)
  # summarise(min(juv.age)) #1  
```

#### Configure, Build & Compile model
```{r}
# configure hmc
# biph0.confhmc <- configureHMC(biph0.model, 
#                                monitors = c("h", "t1", "par")) 
biph3.confmcmc <- configureMCMC(biph3.model,
                                 monitors = c("g","par","lb.mu","l.mu", "s.mu", "smo.age"))

# build mcmc (use buidlHMC() when not using configureHMC())
biph3.mcmc <- buildMCMC(biph3.confmcmc)

# compile model
biph3.c <- compileNimble(biph3.model)

# compile mcmc and specify the project model
#biph0.hmcc <- compileNimble(biph0.hmc)
biph3.mcmcc <- compileNimble(biph3.mcmc)

#### HMC Samples
#help(NUTS)

#biph0.samp <- runMCMC(biph0.hmcc, niter = 500, nburnin = 300, nchains = 2, samplesAsCodaMCMC = TRUE)
biph3.samp <- runMCMC(biph3.mcmcc, niter = 20000, nburnin = 15000, nchains = 1, samplesAsCodaMCMC = TRUE)

# plot observed against predicted
obs <- data %>%
  select(length_mm,tot.age,ind.id) %>%
  mutate(tot.age = round(tot.age),
         observed = length_mm)

predi <- biph3.samp %>%
  gather_draws(l.mu[age,ind.id], sep = ",") %>%
  median_qi() %>%
  rename(predicted = .value) %>%
  mutate(tot.age = age-1) %>%
  filter(tot.age == obs$tot.age & ind.id == obs$ind.id)

predi %>% 
  left_join(obs, by =join_by(tot.age, ind.id)) %>%
  ggplot(aes(x = observed, y = predicted)) +
  geom_point(size = 2, alpha = 0.7) +
  #geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2, alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, color = "red") +
  theme_minimal()

data %>%
  filter(!is.na(smo.age)) %>%
  select(smo.age) %>%
  mutate(t= "obs") %>%
  bind_rows( biph3.samp %>% gather_draws(smo.age[i]) %>% rename(smo.age = .value) %>% mutate(t="pred") ) %>%
  ggplot() +
  geom_density(aes(smo.age, fill = t))

```

```{r}
summary(biph2.samp)
samp <- biph2.samp

pn = 16 # number of plots in each frame
n = ncol(as.matrix(samp$chain1)) # number of nodes
# loop trace through nodes
for(i in seq(0, n, by = pn)){
  m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)
  print(mcmc_trace(samp, pars = vars(i:m)))
}

biph15.samp %>%
  gather_draws(par[np], h[age], mu0) %>%
  median_qi() %>%
  mutate(par = case_when(np == 1 ~ "Linf",
                         np == 2 ~ "K",
                         .variable == "h" ~ "h",
                         .default = NA),
         .value = case_when(par == "K" ~ exp(.value), .default = .value)) %>%
  select(par, .value) %>%
  pivot_wider(names_from = par, values_from = .value) %>%
  expand_grid(age = seq(0, 12, 0.1)) %>%
  mutate(length.a = Linf*(1-exp(-K*age)),
         length.j = mu0 + h) %>%
  ggplot() +
  #geom_point(sallaa %>% filter(!age.type == "sea.only", !is.na(sea.age), !is.na(juv.age)), 
   #          aes(juv.age+sea.age, length_mm), alpha = 0.1, color = "lightblue") +
  geom_line(aes(age, length.a)) +
  geom_line(aes(age, length.j)) +
  theme_light() 

```

### Biphasic 4

Spatiotemporal model for g and par.

```{r}

biph4.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    length_mm[i] ~ dnorm(l.mu[age.index[i], ind.id[i]], sd = sig.l) # age.index = age + 1 to include age 0 individuals. 
    }
  
  # Estimate length at age for each individual (j in nn) and for each age of j (k in age.index=1 to age.index[j], i.e. age 0 to catch age)
  for(j in 1:nn){ # for 
    l.mu[1,j] <- lb.mu + g[spat.unit[j], hatch.year.f[j]] # age 0
    for(k in 2:age.index[j]+1){ 
    #Say that we for hatch.year=2010 want to predict length of an individual of age 3. If we then want to use environmental conditions in 2012 to predict length in 2013, year should be hatch.year + 2 = 2012 but here k = age + 1 = 4. Using k, we need hatch.year + k - 2. BUT, this makes for using hatch year for both k=1 (in l.mu[1,j]) and k=2. Furtherm. k-1 has diffrent meansing in the loop for smolt age and for previous year.
    l.mu[k,j] <- l.mu[k-1,j] + step(smo.age[j] - (k-1))*g[spat.unit[j], hatch.year.f[j]+(k-2)] +
      (1-step(smo.age[j] - (k-1)))*((par[spat.unit[j],hatch.year.f[j]+(k-2),1] - l.mu[k-1,j])*(1 - exp(-exp(par[spat.unit[j],hatch.year.f[j]+(k-1),2]) #*(1 + (tot.age[j] %% 1))
      )))
    }
  }
  
  # estimate smo.age. gamma w mu = ~2.5 makes rate = 2*shape and variance = 2/rate. With sd = 0.5, variance = 0.25,  rate=8 and shape 16.
  for(l in 1:nn){
    smo.age[l] ~ dgamma(shape = s.mu[spat.unit[l]], scale = 0.5^2/2.5)
    }
    
  # Priors  
  sig.l ~ dexp(1/500)
  lb.mu ~ dnorm(10, sd = 5) # length at birth check literature 
  
  # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars])

  # priors for smolt age and juvenile growth rate
  for(i in 1:nsu){ 
    s.mu[i] ~ dnorm(16, sd = 1)
    for(j in minyear:maxyear){ # Take into accuount hatch.year[j]+k-1
      par[i,j,1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
      g[i,j] ~ dnorm(0, sd = 1)  
    }
  }
  #par[1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
  
  mu_par[1] ~ dnorm(1378, sd = 2*139) # Linf from fb
  mu_par[2] ~ dnorm(log(0.43), sd = 0.28) # K from fb
  sig_par[1] ~ dlnorm(log(250),1)
  sig_par[2] ~ dlnorm(log(0.50),1)
  
  })

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k'))))

# Shoudl I avoid estimating params outside of data range??
data <- sallaa %>%
  filter(!is.na(juv.age),
         !is.na(year),
         year > 2000,
         ) %>% 
  slice_sample(n = 2500) %>%
  mutate(smo.age = if_else(age.type == "both", juv.age, NA),
         sea.age = if_else(is.na(sea.age), 0, sea.age),
         tot.age = juv.age + sea.age,
         age.index = as.integer(tot.age + 1), # index for l.mu, add 0.1 to test "tot.age %% 1"
         hatch.year = year-tot.age,
         hatch.year.f = as.numeric(factor(hatch.year, levels = sort(unique(hatch.year)), labels = seq_along(sort(unique(hatch.year))))),
         year.f = as.integer(factor(year)),
         spat.unit = as.integer(factor(spat.unit))) %>%
  select(smo.age, tot.age, length_mm, age.index, year, spat.unit, hatch.year, hatch.year.f) %>%
  mutate(ind.id = row_number()) # ind id

str(data) 
data %>%
  distinct(hatch.year.f, year)

npars <- 2
# get max year by, needed as hatch.year is integer and the last year is not (simpler solution?).  
maxyear <- max(data$hatch.year.f) + data %>% 
  filter(year == max(year)) %>% 
  filter(tot.age == max(tot.age)) %>% 
  distinct(tot.age) %>% pull(tot.age) 

# build model
biph4.model <- nimbleModel(biph4.code,
                           constants = list(npars = npars,
                                             nobs = nrow(data),
                                             nn = nrow(data), # change when having >1 sample per fish!!
                                             nsu = length(unique(data$spat.unit)),
                                             age.index = data$age.index,
                                             ind.id = data$ind.id,
                                             hatch.year.f = data$hatch.year.f, # NOTE FACTOR
                                             tot.age = data$tot.age,
                                             minyear = min(data$hatch.year.f),
                                             maxyear = maxyear,
                                             spat.unit = data$spat.unit),
                           data = data %>% select(-ind.id,-age.index,-spat.unit,-hatch.year,-tot.age, -year, -hatch.year.f))

# check values 
biph4.model$simulate("sig.l")
biph4.model$simulate("mu_par")
biph4.model$simulate("sig_par")
biph4.model$simulate("Ustar")
biph4.model$simulate("U")
biph4.model$simulate("s.mu")
biph4.model$simulate("smo.age")
biph4.model$simulate("lb.mu")
biph4.model$simulate("g")
biph4.model$simulate("par")
biph4.model$simulate("l.mu")

biph4.model$sig.l
biph4.model$U
biph4.model$Ustar
biph4.model$mu_par
biph4.model$sig_par
biph4.model$s.mu
biph4.model$smo.age
biph4.model$lb.mu
biph4.model$g
biph4.model$par[1:11,1:25,1]
exp(biph4.model$par[1:11,1:20,2])
is.na(biph4.model$l.mu)
biph4.model$l.mu >0
sum(which(biph4.model$l.mu<0))
sum(which(biph4.model$l.mu> 0))
#summary(data$smo.age)
#summary(data$tot.age)
# sallaa %>%
# filter(age.type == "both") %>%
#   filter(smo.age >)
# summarise(min(juv.age)) #1  

```

#### Configure, Build & Compile model
```{r}
# configure hmc
# biph0.confhmc <- configureHMC(biph0.model, 
#                                monitors = c("h", "t1", "par")) 
biph4.confmcmc <- configureMCMC(biph4.model,
                                 monitors = c("g","par","lb.mu","l.mu"))

# build mcmc (use buidlHMC() when not using configureHMC())
biph4.mcmc <- buildMCMC(biph4.confmcmc)

# compile model
biph4.c <- compileNimble(biph4.model)

# compile mcmc and specify the project model
#biph0.hmcc <- compileNimble(biph0.hmc)
biph4.mcmcc <- compileNimble(biph4.mcmc)

#### HMC Samples
#help(NUTS)

#biph0.samp <- runMCMC(biph0.hmcc, niter = 500, nburnin = 300, nchains = 2, samplesAsCodaMCMC = TRUE)
biph4.samp <- runMCMC(biph4.mcmcc, niter = 10000, nburnin = 5000, nchains = 1, samplesAsCodaMCMC = TRUE)


```

```{r}
summary(biph4.samp)
samp <- biph4.samp
dim(samp)
traceplot(samp[,9504])
mcmc_trace(samp, pars = vars("par[,,1]", "par[,,2]"))
mcmc_trace(samp, pars = vars("g[1,1]"))
mcmc_trace(samp, pars = vars("l.mu"))
#mcmc_trace(samp, pars = vars("g[,,1]", "lb.mu", ))
pn = 16 # number of plots in each frame
n = 64 #ncol(as.matrix(samp$chain1)) # number of nodes
# loop trace through nodes
for(i in seq(0, n, by = pn)){
  m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)
  #print(traceplot(samp, pars = vars(i:m)))
  print(traceplot(samp[,i:m]))
}
traceplot(samp, varname = )

```

<!-- ### Biphasic old -->

<!-- ```{r} -->
<!-- biph2.code <- nimbleCode({ -->

<!--   # likelihood -->
<!--   for(i in 1:nobs){ -->
<!--     length_mm[i] ~ dnorm(mu[i], sd = sigma) -->

<!--     # Assuming T = A50 (age at 50 smoltification) and disregarding g (cost of maturity) -->
<!--     # when pre.smo == 1, tot.age[i]-juv.age[i] == 0 and the adult growth becomes 0 removing need for if-else. -->
<!--     #HERE should t0 really be juv age? or should the vbgf line intercept y at some other, very low, value??? -->
<!--     mu[i] <- (par[spat.unit[i],1]*(juv.age[i]-par[spat.unit[i],2]))*pre.smo[i] +  -->
<!--       (par[spat.unit[i],3] + bL[spat.unit[i]]*sex[i])*(1-exp(-(par[spat.unit[i],4] + bK[spat.unit[i]]*sex[i])*(sea.age[i]))) -->
<!--     } -->

<!--   # (3*h_pop[Pop[i]]/g_pop[Pop[i]])* -->
<!--   #   (1-exp(-(log(1+g_pop[Pop[i]]/3))* -->
<!--   #            (age[i]-(T50_pop[Pop[i]]+log(1-g_pop[Pop[i]]* -->
<!--   #                                           (T50_pop[Pop[i]]-t1_pop[Pop[i]])/3)/ -->
<!--   #                       log(1+g_pop[Pop[i]]/3))))) -->
<!--   #  -->
<!--   # (3*h[sex[i]]/g[sex[i]])* -->
<!--   #   (1-exp(-(log(1 + g[sex[i]]/3))* -->
<!--   #            (age[i]-(T50Long[i]+log(1-g[sex[i]]* -->
<!--   #                                          (T50Long[i]-t1[sex[i]])/3)/ -->
<!--   #                       log(1+g[sex[i]]/3))))) -->
<!--   #  -->
<!--   # (T50_pop[Pop[i]]+log(1-g_pop[Pop[i]]*(T50_pop[Pop[i]]-t1_pop[Pop[i]])/3)/log(1+g_pop[Pop[i]]/3)) -->

<!--   # Est. juv.age. gamma w mu = ~2 makes rate = 2*shape and variance = 2/rate. With sd = 0.5, variance = 0.25,  rate=8 and shape 16. -->
<!--   for(j in 1:nobs){ -->
<!--     juv.age[j] ~ dgamma(16,8) -->
<!--     } -->

<!--   # estimate sex -->
<!--   for(k in 1:nobs){ -->
<!--     sex[k]~dbern(psex[1]) -->
<!--     } -->
<!--   psex[1] ~ dbeta(mean = 0.5, sd = 0.2)  #prop of males (prob to be 1) -->
<!--   psex[2] <- 1-psex[1] -->

<!--   # Priors   -->
<!--   sigma ~ dexp(1/500) -->

<!--   # LKJ prior on correlation matrix, see NIMBLE manual p45. -->
<!--   Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3 -->
<!--   U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars]) -->

<!--   for(j in 1:nsu){ -->
<!--     par[j, 1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0) -->

<!--     bL[j] ~ dnorm(mubL, sd = sbL) -->
<!--     bK[j] ~ dnorm(mubK, sd = sbK) -->
<!--     } -->

<!--     # mu and 2*sd from fishbase -->
<!--     mu_par[1] ~ dnorm(0.43/2, sd = 2*0.28) # h, slope of linear juv growth   -->
<!--     mu_par[2] ~ dnorm(-1.21, sd = 0.70) # t1, intercept of linear juv growth -->
<!--     mu_par[3] ~ dnorm(1378, sd = 2*139) # Linf from fb -->
<!--     mu_par[4] ~ dnorm(0.43, sd = 2*0.28) # K from fb -->
<!--     sig_par[1] ~ dlnorm(log(0.5),1) -->
<!--     sig_par[2] ~ dlnorm(log(0.7),1) -->
<!--     sig_par[3] ~ dlnorm(log(250),1) -->
<!--     sig_par[4] ~ dlnorm(log(0.50),1) -->

<!--     mubL ~ dnorm(0, 0.01) -->
<!--     mubK ~ dnorm(0, 0.01) -->
<!--     sbL ~ dlnorm(0, 1) -->
<!--     sbK ~ dlnorm(0, 1) -->
<!--     }) -->

<!-- # Function creating the Cholesky of the covar. matrix (p45 Nimble manual) -->
<!-- uppertri_mult_diag <- nimbleFunction( -->
<!--   run = function(mat = double(2), vec = double(1)) { -->
<!--     returnType(double(2)) -->
<!--     p <- length(vec) -->
<!--     out <- matrix(nrow = p, ncol = p, init = FALSE) -->
<!--     for(k in 1:p) -->
<!--       out[ , k] <- mat[ , k] * vec[k] -->
<!--     return(out) -->
<!--    # turn off buildDerivs for the i index -->
<!-- }, buildDerivs = list(run = list(ignore = c('k')))) -->

<!-- swj <- sallaa.all %>% filter(age.type == "juve.only", -->
<!--                              !sai_cou_code == "LV") %>% distinct(spat.unit) %>% pull(spat.unit)  -->

<!-- data <- sallaa %>% -->
<!--   filter(spat.unit %in% swj, -->
<!--          !sai_cou_code == "LV") %>% -->
<!--   mutate(pre.smo = if_else(tot.age <= juv.age, 1, 0), -->
<!--          spat.unit = as.integer(factor(spat.unit)), -->
<!--          sex = as.integer(if_else(sex == "f", 0, 1)))  -->

<!-- nsu <- length(unique(data$spat.unit)) -->
<!-- npars <- 4 -->

<!-- # build model -->
<!-- biph2.model <- nimbleModel(biph2.code, -->
<!--                         constants = list(nsu = nsu, -->
<!--                                          npars = npars, -->
<!--                                          nobs = nrow(data), -->
<!--                                          spat.unit = data$spat.unit), -->
<!--                         #inits=inits(), -->
<!--                         data = data %>% select(tot.age,juv.age,length_mm,pre.smo,sex), -->
<!--                         buildDerivs = TRUE) -->


<!-- ``` -->

<!-- #### Fixing checks -->
<!-- ```{r} -->
<!-- biph2.model$initializeInfo() -->
<!-- biph2.model$simulate("sigma") -->
<!-- biph2.model$simulate("mu_par") -->
<!-- biph2.model$simulate("sig_par") -->
<!-- biph2.model$simulate("Ustar") -->
<!-- biph2.model$simulate("U") -->
<!-- biph2.model$simulate("par") -->
<!-- biph2.model$sigma -->
<!-- biph2.model$U -->
<!-- biph2.model$Ustar -->
<!-- biph2.model$mu_par -->
<!-- biph2.model$sig_par -->
<!-- biph2.model$par -->
<!-- biph2.model$simulate("mubL") -->
<!-- biph2.model$simulate("sbL") -->
<!-- biph2.model$sbL -->
<!-- biph2.model$mubL -->
<!-- biph2.model$simulate("bL") -->
<!-- biph2.model$bL -->
<!-- biph2.model$simulate("mubK") -->
<!-- biph2.model$simulate("sbK") -->
<!-- biph2.model$sbK -->
<!-- biph2.model$mubK -->
<!-- biph2.model$simulate("bK") -->
<!-- biph2.model$bK -->
<!-- #biph2.model$simulate("juv.age") -->
<!-- #max(biph2.model$juv.age)  -->
<!-- #max(data$juv.age, na.rm = TRUE)  -->
<!-- biph2.model$simulate("mu") -->
<!-- biph2.model$mu -->
<!-- # negative mu estimate, why??? -->
<!-- biph2.model$mu[which(biph2.model$mu < 0)] -->
<!-- length(which(biph2.model$mu <= 0)) -->
<!-- # cant see anything odd in the data -->
<!-- data[which(biph2.model$mu <= 0),] -->
<!-- biph.model$length_mm -->
<!-- ``` -->
<!-- #### Configure, Build & Compile model & HMC -->

<!-- ```{r} -->
<!-- # configure hmc -->
<!-- biph2.confhmc <- configureHMC(biph2.model,  -->
<!--                                monitors = c("Ustar", "par", "bL", "bK")) # including Linf and t0 her causes som annoying NaNs, sample in another go! -->
<!--                                #monitors = c("klt", "Ustar", "mu")) -->
<!-- # build mcmc (use buidlHMC() when not using configureHMC()) -->
<!-- biph2.hmc <- buildMCMC(biph2.confhmc) -->

<!-- # compile model -->
<!-- biph2.c <- compileNimble(biph2.model) -->

<!-- # compile mcmc  and specify the project model -->
<!-- biph2.hmcc <- compileNimble(biph2.hmc) -->

<!-- #### HMC Samples -->
<!-- #help(NUTS) -->

<!-- biph2.samp <- runMCMC(biph2.hmcc, niter = 5000, nburnin = 3000, nchains = 2, samplesAsCodaMCMC = TRUE) -->
<!-- ``` -->

<!-- #### Check/plot samples -->

<!-- ```{r} -->
<!-- sam <- biph2.samp -->
<!-- summary(sam) -->

<!-- # length at A1 and A2 corresponds to mean in the data while K and p are off. -->
<!-- sallaa %>% -->
<!--   filter(age.tot %in% c(A1,A2))%>% -->
<!--   summarise(mean = mean(length), .by = age.tot) -->

<!-- # Autocorrelation plots -->
<!-- sam %>% -->
<!--   autocorr.diag(lags = seq(0,1000,5)) %>% -->
<!--   as_tibble(rownames = "lag") %>% -->
<!--   pivot_longer(cols = contains("klt"), names_to = "node" , values_to = "corr") %>% -->
<!--   mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>% -->
<!--   ggplot() + -->
<!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + -->
<!--   facet_wrap(~node) + -->
<!--   theme_light() + -->

<!-- sam %>% -->
<!--   autocorr.diag(lags = seq(0,1000,5)) %>% -->
<!--   as_tibble(rownames = "lag") %>% -->
<!--   # drop the 0 valued Ustar variables (NaN corrs) -->
<!--   select_if(~!any(is.na(.))) %>% -->
<!--   pivot_longer(cols = c(!contains("klt"), -lag), names_to = "node" , values_to = "corr") %>% -->
<!--   mutate(#node = str_replace_all(node, c("\\[" = "", "\\]"="", "," = "_", " "="")), -->
<!--           lag = as.numeric(str_extract(lag, "\\d+"))) %>% -->
<!--   ggplot() + -->
<!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + -->
<!--   facet_wrap(~node) + -->
<!--   theme_light()  -->

<!-- # Trace plots -->
<!-- # number of plots in each frame -->
<!-- pn = 16 -->
<!-- # number of nodes -->
<!-- n = ncol(as.matrix(sam$chain1)) -->

<!-- # loop trace through nodes -->
<!-- for(i in seq(0, n, by = pn)){ -->
<!--   m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)  -->
<!--   print(mcmc_trace(sam, pars = vars(i:m))) -->
<!-- } -->

<!-- #gelman.diag(schnu1a.samp) #Error in chol.default(W) : the leading minor of order 1 is not positive -->
<!-- effectiveSize(schnu1a.samp) -->

<!-- # schnu1a.samp$samples %>% -->
<!-- #   gather_draws(klt[spat.unit,par]) %>% -->
<!-- #   #mutate(val = exp(.value)) %>% -->
<!-- #   ggplot() +  -->
<!-- #   geom_density(aes(x = .value, color = factor(par))) + # age parameter i -->
<!-- #   facet_wrap(par~spat.unit, scales = "free", nrow = 3) + -->
<!-- #   theme_light()  -->
<!-- ``` -->

<!-- <!-- # Biphasic 1 - working but fix priors (I think) --> -->

<!-- <!-- ```{r} --> -->
<!-- <!-- biph.code <- nimbleCode({ --> -->

<!-- <!--   # likelihood --> -->
<!-- <!--   for(i in 1:nobs){ --> -->
<!-- <!--     length_mm[i] ~ dnorm(mu[i], sd = sigma) --> -->

<!-- <!--     # when pre.smo == 1, tot.age[i]-juv.age[i] == 0 and the adult growth becomes 0 removing need for if-else --> -->
<!-- <!--     mu[i] <- (h[spat.unit[i]]*(tot.age[i]-t1[spat.unit[i]]))*pre.smo[i] +  --> -->
<!-- <!--       (Linf[spat.unit[i]] + bL[spat.unit[i]]*sex[i])*(1-exp(-(K[spat.unit[i]] + bK[spat.unit[i]]*sex[i])*(tot.age[i]-juv.age[i]))) --> -->
<!-- <!--     } --> -->

<!-- <!--   # est. juv.age. Gamma dist. juv.age w mu~2 -> rate = 2*scale and variance = 2/scale. With variance = 1, scale=2 and rate=4 --> -->
<!-- <!--   for(j in 1:nobs){ --> -->
<!-- <!--     juv.age[j] ~ dgamma(4,2) --> -->
<!-- <!--   } --> -->

<!-- <!--   # estimate sex --> -->
<!-- <!--   for(k in 1:nobs){ --> -->
<!-- <!--     sex[k]~dbern(psex[1]) --> -->
<!-- <!--   } --> -->
<!-- <!--   psex[1] ~ dbeta(mean = 0.5, sd = 0.2)  #prop of males (prob to be 1) --> -->
<!-- <!--   psex[2] <- 1-psex[1] --> -->

<!-- <!--   # Priors   --> -->
<!-- <!--   sigma ~ dunif(0, 200) --> -->

<!-- <!--   for(j in 1:nsu){ --> -->
<!-- <!--     h[j] ~ dexp(1) --> -->
<!-- <!--     K[j] ~ dexp(1) --> -->
<!-- <!--     t1[j] ~ dnorm(0,1) --> -->
<!-- <!--     Linf[j] ~ dnorm(1300, sd = 300) --> -->
<!-- <!--     bL[j] ~ dnorm(mubL, sd = sbL) --> -->
<!-- <!--     bK[j] ~ dnorm(mubK, sd = sbK) --> -->
<!-- <!--     } --> -->

<!-- <!--     mubL ~ dnorm(0, 0.01) --> -->
<!-- <!--     mubK ~ dnorm(0, 0.01) --> -->
<!-- <!--     sbL ~ dlnorm(0, 1) --> -->
<!-- <!--     sbK ~ dlnorm(0, 1) --> -->
<!-- <!--     }) --> -->


<!-- <!-- swj <- sallaa.all %>% filter(age.type == "juve.only") %>% distinct(spat.unit) %>% pull(spat.unit)  --> -->


<!-- <!-- data <- sallaa %>% --> -->
<!-- <!--   filter(spat.unit %in% swj) %>% --> -->
<!-- <!--   mutate(pre.smo = if_else(tot.age <= juv.age, 1, 0), --> -->
<!-- <!--          spat.unit = as.integer(factor(spat.unit)), --> -->
<!-- <!--          sex = as.integer(if_else(sex == "f", 0, 1))) --> -->

<!-- <!-- sum(is.na(data$juv.age)) --> -->

<!-- <!-- nsu <- length(unique(data$spat.unit)) --> -->

<!-- <!-- # build model --> -->
<!-- <!-- biph.model <- nimbleModel(biph.code, --> -->
<!-- <!--                         constants = list(nsu = nsu, --> -->
<!-- <!--                                          nobs = nrow(data), --> -->
<!-- <!--                                          spat.unit = data$spat.unit), --> -->
<!-- <!--                         #inits=inits(), --> -->
<!-- <!--                         data = data %>% select(tot.age,juv.age,length_mm,pre.smo,sex), --> -->
<!-- <!--                         buildDerivs = TRUE) --> -->


<!-- <!-- ``` --> -->
<!-- <!-- #### Fixing checks --> -->
<!-- <!-- ```{r} --> -->
<!-- <!-- biph.model$initializeInfo() --> -->
<!-- <!-- biph.model$simulate("sigma") --> -->
<!-- <!-- biph.model$simulate("Linf") --> -->
<!-- <!-- biph.model$simulate("t1") --> -->
<!-- <!-- biph.model$simulate("K") --> -->
<!-- <!-- biph.model$simulate("h") --> -->
<!-- <!-- biph.model$sigma --> -->
<!-- <!-- biph.model$Linf --> -->
<!-- <!-- biph.model$K --> -->
<!-- <!-- biph.model$t1 --> -->
<!-- <!-- biph.model$h --> -->
<!-- <!-- biph.model$simulate("mubL") --> -->
<!-- <!-- biph.model$simulate("sbL") --> -->
<!-- <!-- biph.model$sbL --> -->
<!-- <!-- biph.model$mubL --> -->
<!-- <!-- biph.model$simulate("bL") --> -->
<!-- <!-- biph.model$bL --> -->
<!-- <!-- biph.model$simulate("mubK") --> -->
<!-- <!-- biph.model$simulate("sbK") --> -->
<!-- <!-- biph.model$sbK --> -->
<!-- <!-- biph.model$mubK --> -->
<!-- <!-- biph.model$simulate("bK") --> -->
<!-- <!-- biph.model$bK --> -->
<!-- <!-- biph.model$simulate("juv.age") --> -->
<!-- <!-- max(biph.model$juv.age) # !!! --> -->
<!-- <!-- data[which.max(biph.model$juv.age),] --> -->
<!-- <!-- biph.model$simulate("mu") --> -->
<!-- <!-- biph.model$mu --> -->
<!-- <!-- # negative mu estimate, why??? --> -->
<!-- <!-- biph.model$mu[which(biph.model$mu < 0)] --> -->
<!-- <!-- length(which(biph.model$mu <= 0)) --> -->
<!-- <!-- # cant see anything odd in the data --> -->
<!-- <!-- data[which(biph.model$mu <= 0),] --> -->
<!-- <!-- biph.model$length_mm --> -->
<!-- <!-- ``` --> -->
<!-- <!-- #### Configure, Build & Compile model & HMC --> -->

<!-- <!-- ```{r} --> -->
<!-- <!-- # configure hmc --> -->
<!-- <!-- edwilson.confhmc <- configureHMC(edwilson.model,  --> -->
<!-- <!--                                monitors = c("Linf", "K", "h", "t1", "bL", "bK")) # including Linf and t0 her causes som annoying NaNs, sample in another go! --> -->
<!-- <!--                                #monitors = c("klt", "Ustar", "mu")) --> -->
<!-- <!-- # build mcmc (use buidlHMC() when not using configureHMC()) --> -->
<!-- <!-- edwilson.hmc <- buildMCMC(edwilson.confhmc) --> -->

<!-- <!-- # compile model --> -->
<!-- <!-- edwilson.c <- compileNimble(edwilson.model) --> -->

<!-- <!-- # compile mcmc  and specify the project model --> -->
<!-- <!-- edwilson.hmcc <- compileNimble(edwilson.hmc) --> -->

<!-- <!-- #### HMC Samples --> -->

<!-- <!-- #```{r sample} --> -->
<!-- <!-- #help(NUTS) --> -->

<!-- <!-- edwilson.samp <- runMCMC(edwilson.hmcc, niter = 1000, nburnin = 500, nchains = 2, samplesAsCodaMCMC = TRUE) --> -->
<!-- <!-- ``` --> -->

<!-- <!-- #### Check/plot samples --> -->

<!-- <!-- ```{r} --> -->
<!-- <!-- sam <- edwilson.samp --> -->
<!-- <!-- summary(sam) --> -->

<!-- <!-- # length at A1 and A2 corresponds to mean in the data while K and p are off. --> -->
<!-- <!-- sallaa %>% --> -->
<!-- <!--   filter(age.tot %in% c(A1,A2))%>% --> -->
<!-- <!--   summarise(mean = mean(length), .by = age.tot) --> -->


<!-- <!-- # Autocorrelation plots --> -->
<!-- <!-- sam %>% --> -->
<!-- <!--   autocorr.diag(lags = seq(0,1000,5)) %>% --> -->
<!-- <!--   as_tibble(rownames = "lag") %>% --> -->
<!-- <!--   pivot_longer(cols = contains("klt"), names_to = "node" , values_to = "corr") %>% --> -->
<!-- <!--   mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>% --> -->
<!-- <!--   ggplot() + --> -->
<!-- <!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + --> -->
<!-- <!--   facet_wrap(~node) + --> -->
<!-- <!--   theme_light() + --> -->

<!-- <!-- sam %>% --> -->
<!-- <!--   autocorr.diag(lags = seq(0,1000,5)) %>% --> -->
<!-- <!--   as_tibble(rownames = "lag") %>% --> -->
<!-- <!--   # drop the 0 valued Ustar variables (NaN corrs) --> -->
<!-- <!--   select_if(~!any(is.na(.))) %>% --> -->
<!-- <!--   pivot_longer(cols = c(!contains("klt"), -lag), names_to = "node" , values_to = "corr") %>% --> -->
<!-- <!--   mutate(#node = str_replace_all(node, c("\\[" = "", "\\]"="", "," = "_", " "="")), --> -->
<!-- <!--           lag = as.numeric(str_extract(lag, "\\d+"))) %>% --> -->
<!-- <!--   ggplot() + --> -->
<!-- <!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + --> -->
<!-- <!--   facet_wrap(~node) + --> -->
<!-- <!--   theme_light()  --> -->

<!-- <!-- # Trace plots --> -->
<!-- <!-- # number of plots in each frame --> -->
<!-- <!-- pn = 16 --> -->
<!-- <!-- # number of nodes --> -->
<!-- <!-- n = ncol(as.matrix(sam$chain1)) --> -->

<!-- <!-- # loop trace through nodes --> -->
<!-- <!-- for(i in seq(0, n, by = pn)){ --> -->
<!-- <!--   m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)  --> -->
<!-- <!--   print(mcmc_trace(sam, pars = vars(i:m))) --> -->
<!-- <!-- } --> -->

<!-- <!-- #gelman.diag(schnu1a.samp) #Error in chol.default(W) : the leading minor of order 1 is not positive --> -->
<!-- <!-- effectiveSize(schnu1a.samp) --> -->

<!-- <!-- # schnu1a.samp$samples %>% --> -->
<!-- <!-- #   gather_draws(klt[spat.unit,par]) %>% --> -->
<!-- <!-- #   #mutate(val = exp(.value)) %>% --> -->
<!-- <!-- #   ggplot() +  --> -->
<!-- <!-- #   geom_density(aes(x = .value, color = factor(par))) + # age parameter i --> -->
<!-- <!-- #   facet_wrap(par~spat.unit, scales = "free", nrow = 3) + --> -->
<!-- <!-- #   theme_light()  --> -->
<!-- <!-- ``` --> -->



<!-- <!-- ### 1a. L1, L2, p and K  --> -->

<!-- <!-- Ailloud et al. 2017. L_a is assumed normally distributed with expected age given by eq. 2 and 3. --> -->

<!-- <!-- ```{r} --> -->

<!-- <!-- schnu1a.code <- nimbleCode({ --> -->
<!-- <!--   # likelihood --> -->
<!-- <!--   for(i in 1:nobs){ --> -->
<!-- <!--     length[i] ~ dnorm(mu[i], sd = sigma) --> -->

<!-- <!--     mu[i] <- ( klt[1]^klt[2] + (klt[3]^klt[2] - klt[1]^klt[2]) * ( (1-exp( -klt[4]*(age.tot[i]-A1))) / (1-exp(-klt[4]*(A2-A1))) ) )^(1/klt[2]) --> -->

<!-- <!--         } --> -->

<!-- <!--   # Priors  --> -->
<!-- <!--   sigma ~ dunif(0, 200) --> -->

<!-- <!--   # LKJ prior on correlation matrix, see NIMBLE manual p45. --> -->
<!-- <!--   Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3 as in manual --> -->
<!-- <!--   U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_klt[1:npars]) --> -->
<!-- <!--   klt[1:npars] ~ dmnorm(mu_klt[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0) --> -->

<!-- <!--   mu_klt[1] ~ dnorm(100, 0.1)  --> -->
<!-- <!--   mu_klt[2] ~ dnorm(.5, 0.1)  --> -->
<!-- <!--   mu_klt[3] ~ dnorm(1000, 0.1)  --> -->
<!-- <!--   mu_klt[4] ~ dnorm(-1, 0.1)  --> -->

<!-- <!--   sig_klt[1] ~ dlnorm(0,1) --> -->
<!-- <!--   sig_klt[2] ~ dlnorm(0,1) --> -->
<!-- <!--   sig_klt[3] ~ dlnorm(0,1) --> -->
<!-- <!--   sig_klt[4] ~ dlnorm(0,1) --> -->

<!-- <!--   # # Calculate Linf and t0 --> -->
<!-- <!--   # Linf  <- ( (exp(klt[4]*A2)*klt[3]^klt[2] - (exp(klt[4]*A1)*klt[1]^klt[2])) / (exp(klt[4]*A2) - exp(klt[4]*A1)) )^(1/klt[2]) --> -->
<!-- <!--   # t0 <- A1 + A2 - (1/klt[4])*log(Linf) --> -->

<!-- <!-- }) --> -->

<!-- <!-- # Function creating the Cholesky of the covar. matrix (p45 Nimble manual) --> -->
<!-- <!-- uppertri_mult_diag <- nimbleFunction( --> -->
<!-- <!--   run = function(mat = double(2), vec = double(1)) { --> -->
<!-- <!--     returnType(double(2)) --> -->
<!-- <!--     p <- length(vec) --> -->
<!-- <!--     out <- matrix(nrow = p, ncol = p, init = FALSE) --> -->
<!-- <!--     for(k in 1:p) --> -->
<!-- <!--       out[ , k] <- mat[ , k] * vec[k] --> -->
<!-- <!--     return(out) --> -->
<!-- <!--    # turn off buildDerivs for the i index --> -->
<!-- <!-- }, buildDerivs = list(run = list(ignore = c('k'))))  --> -->

<!-- <!-- # initial values generating function (klt[1:4] = L1,p,L2,K) --> -->
<!-- <!-- inits <- function(){ --> -->
<!-- <!--   list(mu_klt = c(rnorm(1, 50, 0.1), --> -->
<!-- <!--                   rnorm(1, 0.5, 0.1), --> -->
<!-- <!--                   rnorm(1, 5000, 0.1), --> -->
<!-- <!--                   rnorm(-1, 1, 0.1)), --> -->
<!-- <!--        sig_klt = c(rlnorm(1, 0, 1), --> -->
<!-- <!--                    rlnorm(1, 0, 1), --> -->
<!-- <!--                    rlnorm(1, 0, 1), --> -->
<!-- <!--                    rlnorm(1, 0, 1)))} --> -->

<!-- <!-- data <- sallaa2 --> -->
<!-- <!-- npars <- 4 --> -->
<!-- <!-- A1 <- min(data$age.tot) --> -->
<!-- <!-- A2 <- max(data$age.tot) --> -->

<!-- <!-- # build model --> -->
<!-- <!-- schnu1a.model <- nimbleModel(schnu1a.code, --> -->
<!-- <!--                              constants = list(npars=npars, --> -->
<!-- <!--                                               A1 = A1, --> -->
<!-- <!--                                               A2 = A2, --> -->
<!-- <!--                                               nobs = nrow(data)), --> -->
<!-- <!--                              inits=inits(), --> -->
<!-- <!--                              data = data %>% select(age.tot,length), --> -->
<!-- <!--                              buildDerivs = TRUE) --> -->
<!-- <!-- ``` --> -->



<!-- <!-- <!-- # Nater et al edited --> --> -->

<!-- <!-- <!-- ```{r} --> --> -->

<!-- <!-- <!-- model{ --> --> -->

<!-- <!-- <!--   ## MODEL PARAMETERS --> --> -->
<!-- <!-- <!--   # mu0 = length at birth --> --> -->
<!-- <!-- <!--   # h0 = baseline river growth rate (year 0) --> --> -->
<!-- <!-- <!--   # betaYR = slope of linear time trend in river growth rate --> --> -->
<!-- <!-- <!--   # k0 = average lake growth rate --> --> -->
<!-- <!-- <!--   # mu_inf0 = average asymptotic length --> --> -->
<!-- <!-- <!--   # betaS = effect of spawning on log(k) --> --> -->
<!-- <!-- <!--   # sigmaR.i = SD of individual REs on h --> --> -->
<!-- <!-- <!--   # sigmaR.t = SD of year REs on h --> --> -->
<!-- <!-- <!--   # sigmaL.i.k = SD of individual REs on log(k) --> --> -->
<!-- <!-- <!--   # sigmaL.t.k = SD of year REs on log(k)  --> --> -->
<!-- <!-- <!--   # sigmaL.i.mu = SD of individual REs on mu_inf --> --> -->
<!-- <!-- <!--   # sigmaR.R = residual process SD of mu in the river --> --> -->
<!-- <!-- <!--   # sigmaL.R = residual process SD of mu in the lake --> --> -->
<!-- <!-- <!--   # sigmaR.M = measurement error SD of L in the river --> --> -->
<!-- <!-- <!--   # sigmaL.M = measurement error SD of L in the lake --> --> -->

<!-- <!-- <!--   # NOTE: All sigmas also have a corresponding precision tau (with the same descriptive lettering, except tau.res, which is precision with regards to residual process variation) --> --> -->


<!-- <!-- <!--   ## AUXILIARY VARIABLES --> --> -->
<!-- <!-- <!--   # mu[i,t] = predicted length of individual i in year t (including residual process variation) --> --> -->
<!-- <!-- <!--   # mu.pred[i,t] = predicted length of individual i in year t --> --> -->
<!-- <!-- <!--   # h[i,t] = river growth rate / increment of individual i in year t --> --> -->
<!-- <!-- <!--   # k[i,t] = lake growth rate of individual i in year t --> --> -->
<!-- <!-- <!--   # mu_inf[i] = asymptotic size of individual i --> --> -->
<!-- <!-- <!--   # muR1[i] = first river length of individual i --> --> -->
<!-- <!-- <!--   # muL1[i] = first lake length of individual i --> --> -->
<!-- <!-- <!--   # muSmolt[i] = length at smolting of individual i --> --> -->
<!-- <!-- <!--   # epsilonR[i] = individual random effect on h of individual i --> --> -->
<!-- <!-- <!--   # epsilonYR[t] = year random effect on h in year t --> --> -->
<!-- <!-- <!--   # epsilonL.k[i] = individual random effect on log(k) of individual i --> --> -->
<!-- <!-- <!--   # epsilonYL.k[t] = year random effect on log(k) in year t --> --> -->
<!-- <!-- <!--   # epsilonL.mu[i] = individual random effect on mu_inf --> --> -->


<!-- <!-- <!--   ## DATA --> --> -->
<!-- <!-- <!--   # L[i,t] = back-calculated length of individual i in year t --> --> -->
<!-- <!-- <!--   # sp[i,t] = spawning status of individual i in year t (0 = not spawning, 1 = spawning) --> --> -->
<!-- <!-- <!--   # first[i] = first non-NA entry in L[i,t] for individual i --> --> -->
<!-- <!-- <!--   # last[i] = last non-NA entry in L[i,t] for individual i --> --> -->
<!-- <!-- <!--   # SY[i] = smolting year of individual i --> --> -->
<!-- <!-- <!--   # N = number of individuals --> --> -->
<!-- <!-- <!--   # Tmax = number of years --> --> -->
<!-- <!-- <!--   # mean.smolt = mean smolt length observed in the population --> --> -->
<!-- <!-- <!--   # sd.smolt = standard deviation of smelt length observed in the population --> --> -->


<!-- <!-- <!--   ####################### --> --> -->
<!-- <!-- <!--   #### PROCESS MODEL #### --> --> -->
<!-- <!-- <!--   ####################### --> --> -->
<!-- <!-- <!--   #--------------------------------------------------------------------------------------- --> --> -->

<!-- <!-- <!--   ## FIRST LENGTH --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->

<!-- <!-- <!--     muR1[i] <- mu0 + h[i,(first[i]-1)] --> --> -->
<!-- <!-- <!--     muL1[i] <- muSmolt[i] + (mu_inf[i] - muSmolt[i])*(1 - exp(-k[i,(first[i]-1)])) --> --> -->

<!-- <!-- <!--     muSmolt[i] ~ dnorm(mean.smolt,tau.smolt) --> --> -->

<!-- <!-- <!--     mu.pred[i,first[i]] <- ifelse(first[i] < SY[i], muR1[i], muL1[i]) --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ## BIPHASIC GROWTH --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->

<!-- <!-- <!--     for(t in first[i]:(last[i]-1)){ --> --> -->

<!-- <!-- <!--       mu.pred[i,t+1] <- ifelse(t < SY[i], mu[i,t]+h[i,t], mu[i,t] + (mu_inf[i]-mu[i,t])*(1 - exp(-k[i,t]))) --> --> -->
<!-- <!-- <!--     } --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ## RESIDUAL PROCESS VARIATION --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->

<!-- <!-- <!--     for(t in first[i]:last[i]){ --> --> -->

<!-- <!-- <!--       tau.res[i,t] <- ifelse(t < SY[i], pow(sigmaR.R, -2), pow(sigmaL.R, -2)) --> --> -->
<!-- <!-- <!--       mu[i,t] ~ dnorm(mu.pred[i,t], tau.res[i,t]) --> --> -->
<!-- <!-- <!--     } --> --> -->
<!-- <!-- <!--   }   --> --> -->

<!-- <!-- <!--   ########################### --> --> -->
<!-- <!-- <!--   #### OBSERVATION MODEL #### --> --> -->
<!-- <!-- <!--   ########################### --> --> -->
<!-- <!-- <!--   #--------------------------------------------------------------------------------------- --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->

<!-- <!-- <!--     for(t in first[i]:last[i]){ --> --> -->

<!-- <!-- <!--       Length[i,su] ~ dnorm(mu[i,t], tau.M[i,t]) --> --> -->
<!-- <!-- <!--       tau.M[i,t] <- ifelse(t < SY[i], pow(sigmaR.M, -2), pow(sigmaL.M, -2)) --> --> -->


<!-- <!-- <!--     } --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ############################## --> --> -->
<!-- <!-- <!--   #### PRIORS & CONSTRAINTS #### --> --> -->
<!-- <!-- <!--   ############################## --> --> -->
<!-- <!-- <!--   #--------------------------------------------------------------------------------------- --> --> -->

<!-- <!-- <!--   for(i in 1:N){  --> --> -->


<!-- <!-- <!--     ## RIVER GROWTH RATE --> --> -->

<!-- <!-- <!--     for(t in (first[i]-1):last[i]){ --> --> -->

<!-- <!-- <!--       h[i,t] <- h0 + betaYR*t + epsilonR[i] + epsilonYR[t] --> --> -->

<!-- <!-- <!--     } --> --> -->


<!-- <!-- <!--     ## LAKE GROTH RATE --> --> -->

<!-- <!-- <!--     for(t in (first[i]-1):last[i]){ --> --> -->

<!-- <!-- <!--       log(k[i,t]) <- log(k0) + betaS*sp[i,t] + epsilonL.k[i] + epsilonYL.k[t] --> --> -->

<!-- <!-- <!--     } --> --> -->

<!-- <!-- <!--     ## ASYMPTOTIC LENGTH  --> --> -->

<!-- <!-- <!--     mu_inf[i] <- mu_inf0 + epsilonL.mu[i] --> --> -->

<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ## MEAN PARAMETERS     --> --> -->
<!-- <!-- <!--   h0 ~ dnorm(0, 1e-06) --> --> -->
<!-- <!-- <!--   mu0 ~ dnorm(0, 1e-06) --> --> -->

<!-- <!-- <!--   k0 ~ dunif(0,5) --> --> -->
<!-- <!-- <!--   mu_inf0 ~ dunif(100,2000) --> --> -->

<!-- <!-- <!--   ## SLOPE PARAMETERS --> --> -->
<!-- <!-- <!--   betaS ~ dnorm(0, 1e-06) --> --> -->
<!-- <!-- <!--   betaYR ~ dnorm(0, 1e-06) --> --> -->

<!-- <!-- <!--   ## INDIVIDUAL RANDOM VARIATION --> --> -->
<!-- <!-- <!--   sigmaR.i ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauR.i <- pow(sigmaR.i, -2) --> --> -->
<!-- <!-- <!--   sigmaL.i.k ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauL.i.k <- pow(sigmaL.i.k, -2) --> --> -->
<!-- <!-- <!--   sigmaL.i.mu ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauL.i.mu <- pow(sigmaL.i.mu, -2) --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->
<!-- <!-- <!--     epsilonR[i] ~ dnorm(0,tauR.i) --> --> -->
<!-- <!-- <!--     epsilonL.k[i] ~ dnorm(0,tauL.i.k) --> --> -->
<!-- <!-- <!--     epsilonL.mu[i] ~ dnorm(0,tauL.i.mu) --> --> -->
<!-- <!-- <!--   }   --> --> -->

<!-- <!-- <!--   ## YEAR RANDOM VARIATION --> --> -->
<!-- <!-- <!--   sigmaR.t ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauR.t <- pow(sigmaR.t, -2) --> --> -->
<!-- <!-- <!--   sigmaL.t.k ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauL.t.k <- pow(sigmaL.t.k, -2) --> --> -->

<!-- <!-- <!--   for(t in 1:Tmax){ --> --> -->
<!-- <!-- <!--     epsilonYR[t] ~ dnorm(0,tauR.t) --> --> -->
<!-- <!-- <!--     epsilonYL.k[t] ~ dnorm(0,tauL.t.k) --> --> -->
<!-- <!-- <!--   }   --> --> -->

<!-- <!-- <!--   ## MEASUREMENT ERROR --> --> -->
<!-- <!-- <!--   sigmaR.M ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   sigmaL.M ~ dgamma(0.001, 0.001) --> --> -->

<!-- <!-- <!--   ## LENGTH AT SMOLTING --> --> -->
<!-- <!-- <!--   tau.smolt <- pow(sigma.smolt, -2) --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->
<!-- <!-- <!--     muSmolt[i] ~ dnorm(mean.smolt,tau.smolt) --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ############################################################# --> --> -->
<!-- <!-- <!--   #### ESTIMATION OF MEASUREMENT ERROR FROM AUXILIARY DATA #### --> --> -->
<!-- <!-- <!--   ############################################################# --> --> -->
<!-- <!-- <!--   #--------------------------------------------------------------------------------------- --> --> -->

<!-- <!-- <!--   ## ADDITIONAL PARAMETERS --> --> -->
<!-- <!-- <!--   # sigma.RS = SD of differences between length estimates from two scales (river) --> --> -->
<!-- <!-- <!--   # sigma.LS = SD of differences between length estimates from two scales (lake) --> --> -->

<!-- <!-- <!--   ## AUXILIARY DATA --> --> -->
<!-- <!-- <!--   # M.backc[x] = length back-calculated from scale for data point x --> --> -->
<!-- <!-- <!--   # M.alive[x] = length measured on alive fish for data point x --> --> -->
<!-- <!-- <!--   # X = Number of data points in comparison of back-calculated vs. alive lengths --> --> -->
<!-- <!-- <!--   # RS.diff[x] = difference of two back-calculated river lengths for data point x --> --> -->
<!-- <!-- <!--   # LS.diff[x] = difference of two back-calculated lake lengths for data point x --> --> -->
<!-- <!-- <!--   # XR = Number of data points in comparison of two back-calculated river lengths --> --> -->
<!-- <!-- <!--   # XL = Number of data points in comparison of two back-calculated lake lengths --> --> -->

<!-- <!-- <!--   ## MEASUREMENT ERROR IN LAKE SCALES (from comparisons of animals measured alive) --> --> -->
<!-- <!-- <!--   for(x in 1:X){ --> --> -->
<!-- <!-- <!--     M.backc[x] ~ dnorm(M.alive[x], pow(sigmaL.M, -2)) --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ## EXTRAPOLATION TO RIVER SCALES USING ERROR RATIO OBTAINED FROM COMPARING SCALES --> --> -->
<!-- <!-- <!--   sigmaR.M <- (sigmaL.M / sigma.LS) * sigma.RS --> --> -->

<!-- <!-- <!--   for(x in XR){ --> --> -->
<!-- <!-- <!--     RS.diff[x] ~ dnorm(0, pow(sigma.RS, -2)) --> --> -->
<!-- <!-- <!--   } --> --> -->

<!-- <!-- <!--   for(x in XL){ --> --> -->
<!-- <!-- <!--     LS.diff[x] ~ dnorm(0, pow(sigma.LS, -2)) --> --> -->
<!-- <!-- <!--   } --> --> -->

<!-- <!-- <!--   ## PRIORS --> --> -->
<!-- <!-- <!--   sigmaL.M ~ dnorm(30, 10)T(0, ) --> --> -->
<!-- <!-- <!--   sigma.RS ~ dnorm(20, 10)T(0, ) --> --> -->
<!-- <!-- <!--   sigma.LS ~ dnorm(50, 10)T(0, ) --> --> -->

<!-- <!-- <!-- } --> --> -->

<!-- <!-- <!-- ``` --> --> -->

<!-- <!-- <!-- # Nater et al  --> --> -->

<!-- <!-- <!-- ```{r} --> --> -->

<!-- <!-- <!-- model{ --> --> -->

<!-- <!-- <!--   ## MODEL PARAMETERS --> --> -->
<!-- <!-- <!--   # mu0 = length at birth --> --> -->
<!-- <!-- <!--   # h0 = baseline river growth rate (year 0) --> --> -->
<!-- <!-- <!--   # betaYR = slope of linear time trend in river growth rate --> --> -->
<!-- <!-- <!--   # k0 = average lake growth rate --> --> -->
<!-- <!-- <!--   # mu_inf0 = average asymptotic length --> --> -->
<!-- <!-- <!--   # betaS = effect of spawning on log(k) --> --> -->
<!-- <!-- <!--   # sigmaR.i = SD of individual REs on h --> --> -->
<!-- <!-- <!--   # sigmaR.t = SD of year REs on h --> --> -->
<!-- <!-- <!--   # sigmaL.i.k = SD of individual REs on log(k) --> --> -->
<!-- <!-- <!--   # sigmaL.t.k = SD of year REs on log(k)  --> --> -->
<!-- <!-- <!--   # sigmaL.i.mu = SD of individual REs on mu_inf --> --> -->
<!-- <!-- <!--   # sigmaR.R = residual process SD of mu in the river --> --> -->
<!-- <!-- <!--   # sigmaL.R = residual process SD of mu in the lake --> --> -->
<!-- <!-- <!--   # sigmaR.M = measurement error SD of L in the river --> --> -->
<!-- <!-- <!--   # sigmaL.M = measurement error SD of L in the lake --> --> -->

<!-- <!-- <!--   # NOTE: All sigmas also have a corresponding precision tau (with the same descriptive lettering, except tau.res, which is precision with regards to residual process variation) --> --> -->


<!-- <!-- <!--   ## AUXILIARY VARIABLES --> --> -->
<!-- <!-- <!--   # mu[i,t] = predicted length of individual i in year t (including residual process variation) --> --> -->
<!-- <!-- <!--   # mu.pred[i,t] = predicted length of individual i in year t --> --> -->
<!-- <!-- <!--   # h[i,t] = river growth rate / increment of individual i in year t --> --> -->
<!-- <!-- <!--   # k[i,t] = lake growth rate of individual i in year t --> --> -->
<!-- <!-- <!--   # mu_inf[i] = asymptotic size of individual i --> --> -->
<!-- <!-- <!--   # muR1[i] = first river length of individual i --> --> -->
<!-- <!-- <!--   # muL1[i] = first lake length of individual i --> --> -->
<!-- <!-- <!--   # muSmolt[i] = length at smolting of individual i --> --> -->
<!-- <!-- <!--   # epsilonR[i] = individual random effect on h of individual i --> --> -->
<!-- <!-- <!--   # epsilonYR[t] = year random effect on h in year t --> --> -->
<!-- <!-- <!--   # epsilonL.k[i] = individual random effect on log(k) of individual i --> --> -->
<!-- <!-- <!--   # epsilonYL.k[t] = year random effect on log(k) in year t --> --> -->
<!-- <!-- <!--   # epsilonL.mu[i] = individual random effect on mu_inf --> --> -->


<!-- <!-- <!--   ## DATA --> --> -->
<!-- <!-- <!--   # L[i,t] = back-calculated length of individual i in year t --> --> -->
<!-- <!-- <!--   # sp[i,t] = spawning status of individual i in year t (0 = not spawning, 1 = spawning) --> --> -->
<!-- <!-- <!--   # first[i] = first non-NA entry in L[i,t] for individual i --> --> -->
<!-- <!-- <!--   # last[i] = last non-NA entry in L[i,t] for individual i --> --> -->
<!-- <!-- <!--   # SY[i] = smolting year of individual i --> --> -->
<!-- <!-- <!--   # N = number of individuals --> --> -->
<!-- <!-- <!--   # Tmax = number of years --> --> -->
<!-- <!-- <!--   # mean.smolt = mean smolt length observed in the population --> --> -->
<!-- <!-- <!--   # sd.smolt = standard deviation of smelt length observed in the population --> --> -->


<!-- <!-- <!--   ####################### --> --> -->
<!-- <!-- <!--   #### PROCESS MODEL #### --> --> -->
<!-- <!-- <!--   ####################### --> --> -->
<!-- <!-- <!--   #--------------------------------------------------------------------------------------- --> --> -->

<!-- <!-- <!--   ## FIRST LENGTH --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->

<!-- <!-- <!--     muR1[i] <- mu0 + h[i,(first[i]-1)] --> --> -->
<!-- <!-- <!--     muL1[i] <- muSmolt[i] + (mu_inf[i] - muSmolt[i])*(1 - exp(-k[i,(first[i]-1)])) --> --> -->

<!-- <!-- <!--     muSmolt[i] ~ dnorm(mean.smolt,tau.smolt) --> --> -->

<!-- <!-- <!--     mu.pred[i,first[i]] <- ifelse(first[i] < SY[i], muR1[i], muL1[i]) --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ## BIPHASIC GROWTH --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->

<!-- <!-- <!--     for(t in first[i]:(last[i]-1)){ --> --> -->

<!-- <!-- <!--       mu.pred[i,t+1] <- ifelse(t < SY[i], mu[i,t]+h[i,t], mu[i,t] + (mu_inf[i]-mu[i,t])*(1 - exp(-k[i,t]))) --> --> -->
<!-- <!-- <!--     } --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ## RESIDUAL PROCESS VARIATION --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->

<!-- <!-- <!--     for(t in first[i]:last[i]){ --> --> -->

<!-- <!-- <!--       tau.res[i,t] <- ifelse(t < SY[i], pow(sigmaR.R, -2), pow(sigmaL.R, -2)) --> --> -->
<!-- <!-- <!--       mu[i,t] ~ dnorm(mu.pred[i,t], tau.res[i,t]) --> --> -->
<!-- <!-- <!--     } --> --> -->
<!-- <!-- <!--   }   --> --> -->

<!-- <!-- <!--   ########################### --> --> -->
<!-- <!-- <!--   #### OBSERVATION MODEL #### --> --> -->
<!-- <!-- <!--   ########################### --> --> -->
<!-- <!-- <!--   #--------------------------------------------------------------------------------------- --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->

<!-- <!-- <!--     for(t in first[i]:last[i]){ --> --> -->

<!-- <!-- <!--       tau.M[i,t] <- ifelse(t < SY[i], pow(sigmaR.M, -2), pow(sigmaL.M, -2)) --> --> -->
<!-- <!-- <!--       L[i,t] ~ dnorm(mu[i,t], tau.M[i,t]) --> --> -->

<!-- <!-- <!--     } --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ############################## --> --> -->
<!-- <!-- <!--   #### PRIORS & CONSTRAINTS #### --> --> -->
<!-- <!-- <!--   ############################## --> --> -->
<!-- <!-- <!--   #--------------------------------------------------------------------------------------- --> --> -->

<!-- <!-- <!--   for(i in 1:N){  --> --> -->


<!-- <!-- <!--     ## RIVER GROWTH RATE --> --> -->

<!-- <!-- <!--     for(t in (first[i]-1):last[i]){ --> --> -->

<!-- <!-- <!--       h[i,t] <- h0 + betaYR*t + epsilonR[i] + epsilonYR[t] --> --> -->

<!-- <!-- <!--     } --> --> -->


<!-- <!-- <!--     ## LAKE GROTH RATE --> --> -->

<!-- <!-- <!--     for(t in (first[i]-1):last[i]){ --> --> -->

<!-- <!-- <!--       log(k[i,t]) <- log(k0) + betaS*sp[i,t] + epsilonL.k[i] + epsilonYL.k[t] --> --> -->

<!-- <!-- <!--     } --> --> -->

<!-- <!-- <!--     ## ASYMPTOTIC LENGTH  --> --> -->

<!-- <!-- <!--     mu_inf[i] <- mu_inf0 + epsilonL.mu[i] --> --> -->

<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ## MEAN PARAMETERS     --> --> -->
<!-- <!-- <!--   h0 ~ dnorm(0, 1e-06) --> --> -->
<!-- <!-- <!--   mu0 ~ dnorm(0, 1e-06) --> --> -->

<!-- <!-- <!--   k0 ~ dunif(0,5) --> --> -->
<!-- <!-- <!--   mu_inf0 ~ dunif(100,2000) --> --> -->

<!-- <!-- <!--   ## SLOPE PARAMETERS --> --> -->
<!-- <!-- <!--   betaS ~ dnorm(0, 1e-06) --> --> -->
<!-- <!-- <!--   betaYR ~ dnorm(0, 1e-06) --> --> -->

<!-- <!-- <!--   ## INDIVIDUAL RANDOM VARIATION --> --> -->
<!-- <!-- <!--   sigmaR.i ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauR.i <- pow(sigmaR.i, -2) --> --> -->
<!-- <!-- <!--   sigmaL.i.k ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauL.i.k <- pow(sigmaL.i.k, -2) --> --> -->
<!-- <!-- <!--   sigmaL.i.mu ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauL.i.mu <- pow(sigmaL.i.mu, -2) --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->
<!-- <!-- <!--     epsilonR[i] ~ dnorm(0,tauR.i) --> --> -->
<!-- <!-- <!--     epsilonL.k[i] ~ dnorm(0,tauL.i.k) --> --> -->
<!-- <!-- <!--     epsilonL.mu[i] ~ dnorm(0,tauL.i.mu) --> --> -->
<!-- <!-- <!--   }   --> --> -->

<!-- <!-- <!--   ## YEAR RANDOM VARIATION --> --> -->
<!-- <!-- <!--   sigmaR.t ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauR.t <- pow(sigmaR.t, -2) --> --> -->
<!-- <!-- <!--   sigmaL.t.k ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   tauL.t.k <- pow(sigmaL.t.k, -2) --> --> -->

<!-- <!-- <!--   for(t in 1:Tmax){ --> --> -->
<!-- <!-- <!--     epsilonYR[t] ~ dnorm(0,tauR.t) --> --> -->
<!-- <!-- <!--     epsilonYL.k[t] ~ dnorm(0,tauL.t.k) --> --> -->
<!-- <!-- <!--   }   --> --> -->

<!-- <!-- <!--   ## MEASUREMENT ERROR --> --> -->
<!-- <!-- <!--   sigmaR.M ~ dgamma(0.001, 0.001) --> --> -->
<!-- <!-- <!--   sigmaL.M ~ dgamma(0.001, 0.001) --> --> -->

<!-- <!-- <!--   ## LENGTH AT SMOLTING --> --> -->
<!-- <!-- <!--   tau.smolt <- pow(sigma.smolt, -2) --> --> -->

<!-- <!-- <!--   for(i in 1:N){ --> --> -->
<!-- <!-- <!--     muSmolt[i] ~ dnorm(mean.smolt,tau.smolt) --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ############################################################# --> --> -->
<!-- <!-- <!--   #### ESTIMATION OF MEASUREMENT ERROR FROM AUXILIARY DATA #### --> --> -->
<!-- <!-- <!--   ############################################################# --> --> -->
<!-- <!-- <!--   #--------------------------------------------------------------------------------------- --> --> -->

<!-- <!-- <!--   ## ADDITIONAL PARAMETERS --> --> -->
<!-- <!-- <!--   # sigma.RS = SD of differences between length estimates from two scales (river) --> --> -->
<!-- <!-- <!--   # sigma.LS = SD of differences between length estimates from two scales (lake) --> --> -->

<!-- <!-- <!--   ## AUXILIARY DATA --> --> -->
<!-- <!-- <!--   # M.backc[x] = length back-calculated from scale for data point x --> --> -->
<!-- <!-- <!--   # M.alive[x] = length measured on alive fish for data point x --> --> -->
<!-- <!-- <!--   # X = Number of data points in comparison of back-calculated vs. alive lengths --> --> -->
<!-- <!-- <!--   # RS.diff[x] = difference of two back-calculated river lengths for data point x --> --> -->
<!-- <!-- <!--   # LS.diff[x] = difference of two back-calculated lake lengths for data point x --> --> -->
<!-- <!-- <!--   # XR = Number of data points in comparison of two back-calculated river lengths --> --> -->
<!-- <!-- <!--   # XL = Number of data points in comparison of two back-calculated lake lengths --> --> -->

<!-- <!-- <!--   ## MEASUREMENT ERROR IN LAKE SCALES (from comparisons of animals measured alive) --> --> -->
<!-- <!-- <!--   for(x in 1:X){ --> --> -->
<!-- <!-- <!--     M.backc[x] ~ dnorm(M.alive[x], pow(sigmaL.M, -2)) --> --> -->
<!-- <!-- <!--   } --> --> -->


<!-- <!-- <!--   ## EXTRAPOLATION TO RIVER SCALES USING ERROR RATIO OBTAINED FROM COMPARING SCALES --> --> -->
<!-- <!-- <!--   sigmaR.M <- (sigmaL.M / sigma.LS) * sigma.RS --> --> -->

<!-- <!-- <!--   for(x in XR){ --> --> -->
<!-- <!-- <!--     RS.diff[x] ~ dnorm(0, pow(sigma.RS, -2)) --> --> -->
<!-- <!-- <!--   } --> --> -->

<!-- <!-- <!--   for(x in XL){ --> --> -->
<!-- <!-- <!--     LS.diff[x] ~ dnorm(0, pow(sigma.LS, -2)) --> --> -->
<!-- <!-- <!--   } --> --> -->

<!-- <!-- <!--   ## PRIORS --> --> -->
<!-- <!-- <!--   sigmaL.M ~ dnorm(30, 10)T(0, ) --> --> -->
<!-- <!-- <!--   sigma.RS ~ dnorm(20, 10)T(0, ) --> --> -->
<!-- <!-- <!--   sigma.LS ~ dnorm(50, 10)T(0, ) --> --> -->

<!-- <!-- <!-- } --> --> -->

<!-- <!-- <!-- ``` --> --> -->


## TEsting 

```{r}
bipht.code <- nimbleCode({
  
  # likelihood
  # for(i in 1:nobs){
  #   
  #   # amu[i] ~ dnorm(mean = mu[i], sd = 1)
  #   # mu[i] <- juv.age[i]
  #   
  #   lmu[i] ~ dnorm(mul[i], sd = 1)
  #   mul[i] <- length_mm[i]
  # 
  # }
  
  for(j in 1:id0_n){
    
    mu0[j] ~ dnorm(mean = mum[j], sd = 1)
    mum[j] <- length_mm[id0[j]]
                        
  }
  
  # priors
  
  #mu ~ dnorm(log(1),1)
  
  
})

data <- sallaa %>%
  select(juv.age, length_mm) %>%
  drop_na(juv.age, length_mm) #%>%
  #mutate(min.age = min(juv.age)) %>%
  #slice_sample(n=10000)
  
id0 = which(data$juv.age == min(data$juv.age))
id0_n <- length(id0)


# build model
bipht.model <- nimbleModel(bipht.code,
                        constants = list(nobs = nrow(data),
                                         id0_n = id0_n,
                                         id0 = id0),
                        data = data)


# bipht.model$simulate("mul")
# bipht.model$simulate("amu")
bipht.model$simulate("mum")
bipht.model$simulate("mu0")
bipht.model$mu0
bipht.model$mum

bipht.model$mu_par
bipht.model$sig_par
bipht.model$t1
bipht.model$h
bipht.model$par

```

