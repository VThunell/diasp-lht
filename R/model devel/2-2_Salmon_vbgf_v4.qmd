---
title: "Salmon VBGF model v3"
author: "Viktor Thunell" 
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    code-fold: true
    code-summary: "Show code"
    page-layout: full
    embed-resources: true
    toc: true
knitr: 
  opts_chunk:
    fig.align: center
    out-width: 80%
editor: source
execute: 
  echo: true
  eval: true
  cache: true
---

## Load libraries
```{r libs}
#| message: false
#| warning: false
#| cache: false

# Load libraries, install if needed
pkgs <- c("tidyverse", "tidylog", "devtools","viridis","nls.multstart", "broom", "patchwork", "coda", "boot", "tidybayes","bayesplot", "nimbleHMC", "here")

# remotes::install_github("nimble-dev/nimble", ref = "devel", subdir = "packages/nimble")

if(length(setdiff(pkgs,rownames(installed.packages()))) > 0){
    install.packages(setdiff(pkgs, rownames(installed.packages())), dependencies = T)
  }

invisible(lapply(pkgs, library, character.only = T))

options(ggplot2.continuous.colour = "viridis")
theme_set(theme_light()) # check why global theme option not working when rendering
# Set path

home <- here::here()
```

## Read data
```{r}
#| message: false
#| warning: false
#| cache: false

sallaa <- readRDS(file = paste0(home,"/data/data-for-2-2/salmon-laa_2025-05-02.RData")) %>%
  #filter out non-aged individuals (~34000 individuals)
  filter(!(is.na(age.sea) & is.na(age.sm))) #%>% 

```

For now I will use the "both" type only.
```{r}
# Create a new dataset 
sallaa2 <- sallaa %>%
  filter(age.type == "both")

sallaa2 %>%
  drop_na(sex) %>%
  ggplot(aes(age.tot, length, color = sex)) +
  geom_point() +
  facet_wrap(~sex) +
  scale_x_continuous(breaks = seq(0, 13, 1) )

```

# Hists of age and length
```{r}

# If dropping all inds where both sea and sm age is NA 
sallaa2 %>% 
  ggplot() +
  geom_density(aes(x = age.tot), fill = "deeppink", alpha = 0.5) +
  xlim(0, 13) +
  
sallaa2 %>% 
  ggplot() + 
  geom_density(aes(x = length), fill = "deeppink", alpha = 0.5)
  
sallaa2 %>% 
  ggplot() +
  geom_density(aes(x = length, fill = factor(age.tot)), alpha = 0.5) +
  #geom_histogram(aes(x = length)) +
  facet_wrap(~age.tot, scales = "free")
```

**NOTE in code below: Ive silenced warmings to make html manageble when "logProb of data node length[1:nobs]: logProb less than -1e12."**

## Spatial model w Multivariate normal prior on VGBF params

### 1a. Spatial sex covar. for Linf and k 

```{r}
vbgf1a.code <- nimbleCode({
  # likelihood
  for(i in 1:nobs){
    length[i] ~ dnorm(mu[i], sd = sigma)
    mu[i] <- (klt[spat.unit[i],1] + b1[spat.unit[i]]*sex[i]) *
      (1-exp(-(klt[spat.unit[i],2] + b2[spat.unit[i]]*sex[i]) * (age.tot[i]-klt[spat.unit[i],3])))
    }
  
  # Priors 
  sigma ~ dunif(0, 250)
  
  # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_klt[1:npars])
  
  for(j in 1:nsu){
   klt[j, 1:npars] ~ dmnorm(mu_klt[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
    
   b1[j] ~ dnorm(mub1, sd = sb1)
   b2[j] ~ dnorm(mub2, sd = sb2)
  }
  
  # mu and 2*sd from fishbase
  mu_klt[1] ~ dnorm(1378, sd = 2*139) 
  mu_klt[2] ~ dnorm(0.43, sd = 2*0.28)
  mu_klt[3] ~ dnorm(-1.21, sd = 1.40) 
  # mu and 2*sd from fishbase
  sig_klt[1] ~ dlnorm(log(139),1)
  sig_klt[2] ~ dlnorm(log(0.43),1)
  sig_klt[3] ~ dlnorm(log(1.40),1)

  mub1 ~ dnorm(0, 0.01)
  mub2 ~ dnorm(0, 0.01)
  sb1 ~ dlnorm(0, 1)
  sb2 ~ dlnorm(0, 1)
  
})

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k')))) 

npars <- 3
nsu <- length(unique(sallaa2$spat.unit))

# initial values generating function
inits <- function(){
  list(mu_klt = c(rnorm(1,1300,140),
                  rnorm(1,0.4,0.3),
                  rnorm(1,-1.2,1.4)),
       mub1 = rnorm(1,100,50),
       mub2 = rnorm(1,0.5,0.5),
       sig_klt = c(rlnorm(1,-0.60,0.30),
                   rlnorm(1,-3,0.05),
                   rlnorm(1,-1,0.05)))}

data_1a <- sallaa2 %>%
  mutate(sex = as.integer(if_else(sex == "f", 0, 1)),
         spat.unit = as.integer(factor(sallaa2$spat.unit))) %>% 
  drop_na(sex)

# build model
vbgf1a.model <- nimbleModel(vbgf1a.code,
                        constants = list(npars=npars, 
                                         nsu = nsu, 
                                         nobs = nrow(data_1a), 
                                         spat.unit = data_1a$spat.unit),
                        inits=inits(),
                        data = data_1a %>% select(age.tot,length,sex),
                        buildDerivs = TRUE)
```

#### Configure, Build & Compile model & HMC

```{r}
# configure hmc
vbgf1a.confhmc <- configureHMC(vbgf1a.model, 
                               monitors = c("klt", "b1", "b2", "Ustar"),
                               enableWAIC = TRUE)

# build mcmc (use buidlHMC() when not using configureHMC())
vbgf1a.hmc <- buildMCMC(vbgf1a.confhmc)

# compile model
vbgf1a.c <- compileNimble(vbgf1a.model)

# compile mcmc  and specify the project model
vbgf1a.hmcc <- compileNimble(vbgf1a.hmc)#, project = vbgf1b.c)

```
#### HMC Samples

```{r sample}
help(NUTS)

vbgf1a.samp <- runMCMC(vbgf1a.hmcc, niter = 2000, nburnin = 800, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC=TRUE)
```

#### Check/plot samples

```{r}
summary(vbgf1a.samp$samples)

# Autocorrelation plots
vbgf1a.samp$samples %>%
  autocorr.diag(lags = seq(0,1000,5)) %>%
  as_tibble(rownames = "lag") %>%
  pivot_longer(cols = contains("klt"), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() +

vbgf1a.samp$samples %>%
  autocorr.diag(lags = seq(0,1000,5)) %>%
  as_tibble(rownames = "lag") %>%
  # drop the 0 valued Ustar variables (NaN corrs)
  select_if(~!any(is.na(.))) %>%
  pivot_longer(cols = c(!contains("klt"), -lag), names_to = "node" , values_to = "corr") %>%
  mutate(#node = str_replace_all(node, c("\\[" = "", "\\]"="", "," = "_", " "="")),
          lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() 

mcmc_trace(vbgf1a.samp$samples, pars = vars(1:12))
mcmc_trace(vbgf1a.samp$samples, pars = vars(12:23))
mcmc_trace(vbgf1a.samp$samples, pars = vars(24:33))

#gelman.diag(vbgf1a.samp$samples[1:2,])
effectiveSize(vbgf1a.samp$samples)

# vbgf1a.samp$samples %>%
#   gather_draws(klt[spat.unit,par]) %>%
#   #mutate(val = exp(.value)) %>%
#   ggplot() + 
#   geom_density(aes(x = .value, color = factor(par))) + # age parameter i
#   facet_wrap(par~spat.unit, scales = "free", nrow = 3) +
#   theme_light() 
```

### 1b. Parallell version of 1a.

```{r}

library(parallel)
#specifying the number of cores we want the cluster to operate across.

this_cluster <- makeCluster(2)
set.seed(10560)

run_MCMC_allcode <- function(seed, data, code) {
  library(nimbleHMC)
  library(tidyverse)

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k')))) 

assign('uppertri_mult_diag', uppertri_mult_diag, envir = .GlobalEnv)

npars <- 3
nsu <- length(unique(data$spat.unit))

#initial values generating function
inits <- function(){
  list(mu_klt = c(rnorm(1,1300,140),
                  rnorm(1,0.4,0.3),
                  rnorm(1,-1.2,1.4)),
       mub1 = rnorm(1,100,50),
       mub2 = rnorm(1,0.5,0.5),
       sig_klt = c(rlnorm(1,-0.60,0.30),
                   rlnorm(1,-3,0.05),
                   rlnorm(1,-1,0.05)))}

# build model
vbgf1a.model <- nimbleModel(code,
                            constants = list(npars=npars, 
                                         nsu = nsu, 
                                         nobs = nrow(data), 
                                         spat.unit = data$spat.unit),
                            inits=inits(),
                            data = data %>% select(age.tot,length,sex),
                            buildDerivs = TRUE)

# Configure, Build & Compile model & HMC

# configure hmc
vbgf1a.confhmc <- configureHMC(vbgf1a.model, 
                               monitors = c("klt", "b1", "b2", "Ustar"),
                               enableWAIC = TRUE)

# build mcmc (use buidlHMC() when not using configureHMC())
vbgf1a.hmc <- buildMCMC(vbgf1a.confhmc)

# compile model
vbgf1a.c <- compileNimble(vbgf1a.model)

# compile mcmc  and specify the project model
vbgf1a.hmcc <- compileNimble(vbgf1a.hmc)#, project = vbgf1b.c)

# HMC Samples
vbgf1a.samp <- runMCMC(vbgf1a.hmcc, niter = 3000, nburnin = 2000, samplesAsCodaMCMC = TRUE, setSeed = seed, WAIC = TRUE)

  return(vbgf1a.samp)
}

paral.samples <- parLapply(cl = this_cluster,
                          X = 1:2, 
                          fun = run_MCMC_allcode, 
                          data = data_1a, code = vbgf1a.code)

stopCluster(this_cluster)
```

#### Check/plot samples

```{r}
str(paral.samples)
summary(paral.samples[[2]]$samples)

# Autocorrelation plots
paral.samples[[2]]$samples %>%
  autocorr.diag(lags = seq(0,1000,5)) %>%
  as_tibble(rownames = "lag") %>%
  pivot_longer(cols = contains("klt"), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() +

paral.samples[[2]]$samples %>%
  autocorr.diag(lags = seq(0,1000,5)) %>%
  as_tibble(rownames = "lag") %>%
  # drop the 0 valued Ustar variables (NaN corrs)
  select_if(~!any(is.na(.))) %>%
  pivot_longer(cols = c(!contains("klt"), -lag), names_to = "node" , values_to = "corr") %>%
  mutate(#node = str_replace_all(node, c("\\[" = "", "\\]"="", "," = "_", " "="")),
          lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() 

mcmc_trace(paral.samples[[1]]$samples, pars = vars(1:12))
mcmc_trace(paral.samples[[1]]$samples, pars = vars(12:23))
mcmc_trace(paral.samples[[1]]$samples, pars = vars(24:33))

gelman.diag(chain_outpu$samples). # How to do this for paralleled chains?
effectiveSize(paral.samples[[2]]$samples)

paral.samples[[1]]$WAIC
paral.samples[[2]]$WAIC

# vbgf1a.samp$samples %>%
#   gather_draws(klt[spat.unit,par]) %>%
#   #mutate(val = exp(.value)) %>%
#   ggplot() + 
#   geom_density(aes(x = .value, color = factor(par))) + # age parameter i
#   facet_wrap(par~spat.unit, scales = "free", nrow = 3) +
#   theme_light() 
```

### 2a. Including NA-sex

```{r}
sallaa2 %>% 
  count(sex) # ~30% NA
sallaa2 %>% 
  count(sex,age.tot)
sallaa2 %>% 
  ggplot() +
  geom_density(aes(x = length, fill = factor(sex)), alpha = 0.5) +
  #geom_histogram(aes(x = length)) +
  facet_wrap(~age.tot, scales = "free")
```

```{r}
vbgf2a.code <- nimbleCode({
  # likelihood
  for(i in 1:nobs){
    length[i] ~ dnorm(mu[i], sd = sigma)
    mu[i] <- (klt[spat.unit[i],1] + b1[spat.unit[i]]*sex[i]) *
      (1-exp(-(klt[spat.unit[i],2] + b2[spat.unit[i]]*sex[i]) * (age.tot[i]-klt[spat.unit[i],3])))
  }
  
  for(k in 1:nobs){
    sex[k]~dbern(psex[1]) #sex coded as 0 or 1
    #sex[k]~dbern(psex[])
    #psex[k] <- age[k] ... length[k] # add
  }
  psex[1] ~ dbeta(mean = 0.6, sd = 0.2)  #prop of males (prob to be 1)
  psex[2] <- 1-psex[1]
    
  # Priors 
  sigma ~ dunif(0, 250)
  
  # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_klt[1:npars])
  
  for(j in 1:nsu){
   klt[j, 1:npars] ~ dmnorm(mu_klt[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
    
   b1[j] ~ dnorm(mub1, sd = sb1)
   b2[j] ~ dnorm(mub2, sd = sb2)
  }
  
  # mu and 2*sd from fishbase
  mu_klt[1] ~ dnorm(1378, sd = 2*139) 
  mu_klt[2] ~ dnorm(0.43, sd = 2*0.28)
  mu_klt[3] ~ dnorm(-1.21, sd = 1.40) 
  # mu and 2*sd from fishbase
  sig_klt[1] ~ dlnorm(log(139),1)
  sig_klt[2] ~ dlnorm(log(0.43),1)
  sig_klt[3] ~ dlnorm(log(1.40),1)

  mub1 ~ dnorm(0, 0.01)
  mub2 ~ dnorm(0, 0.01)
  sb1 ~ dlnorm(0, 1)
  sb2 ~ dlnorm(0, 1)
  
})

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k')))) 

npars <- 3
nsu <- length(unique(sallaa2$spat.unit))

# initial values generating function
inits <- function(){
  list(mu_klt = c(rnorm(1,1300,140),
                  rnorm(1,0.4,0.3),
                  rnorm(1,-1.2,1.4)),
       mub1 = rnorm(1,100,50),
       mub2 = rnorm(1,0.5,0.5),
       sig_klt = c(rlnorm(1,-0.60,0.30),
                   rlnorm(1,-3,0.05),
                   rlnorm(1,-1,0.05)))}

data <- sallaa2 %>%
  mutate(sex = as.integer(if_else(sex == "f", 0, 1)),
         spat.unit = as.integer(factor(sallaa2$spat.unit)))

# build model
vbgf2a.model <- nimbleModel(vbgf2a.code,
                        constants = list(npars=npars, 
                                         nsu = nsu, 
                                         nobs = nrow(data), 
                                         spat.unit = data$spat.unit),
                        inits=inits(),
                        data = data
                        %>% select(age.tot,length,sex),
                        buildDerivs = TRUE)

```

#### Configure, Build & Compile model & HMC

```{r}
# configure hmc
vbgf2a.confhmc <- configureHMC(vbgf2a.model, 
                               monitors = c("klt", "b1", "b2", "Ustar", "sex"),
                               enableWAIC = TRUE)

# build mcmc (use buidlHMC() when not using configureHMC())
vbgf2a.hmc <- buildMCMC(vbgf2a.confhmc)

# compile model
vbgf2a.c <- compileNimble(vbgf2a.model)

# the nodes that depend on sex
vbgf2a.c$getDependencies(c("sex")) %>%
  as_tibble() %>%
  mutate(nodes = str_extract(value, "\\w+")) %>%
  distinct(nodes)

# compile mcmc  and specify the project model
vbgf2a.hmcc <- compileNimble(vbgf2a.hmc)#, project = vbgf2a.c)


```
#### HMC Samples

```{r}
#help(NUTS)

vbgf2a.samp <- runMCMC(vbgf2a.hmcc, niter = 500, nburnin = 300, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC=TRUE)

#vbgf2a.samp <- readRDS(file = paste0(home,"/vbgf2a.samp_20250517"))
```

#### Check/plot samples

```{r}
summary(vbgf2a.samp$samples)

# length at age for the inds where sex is assigned by the model. 
data %>%
  bind_cols(sex2 = vbgf2a.c$sex) %>%
  filter(row_number() %in% which(is.na(data$sex))) %>%
  ggplot(aes(age.tot, length, color = factor(sex2))) +
  geom_point() 

# deselect the sex nods to reduce sample object size
acfnodes <- colnames(vbgf2a.samp$samples$chain1)[-which(
  str_detect(colnames(vbgf2a.samp$samples$chain1), "sex"))]
vbgf2a.samp$samples[,c(acfnodes)]

# Autocorrelation plots
vbgf2a.samp$samples[,c(acfnodes)] %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  pivot_longer(cols = contains("klt"), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() +

vbgf2a.samp$samples[,c(acfnodes)] %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  # drop the 0 valued Ustar variables (NaN corrs)
  select_if(~!any(is.na(.))) %>%
  pivot_longer(cols = c(!contains("klt"), -lag), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() 

mcmc_trace(vbgf2a.samp$samples[,c(acfnodes)], pars = vars(1:16))
mcmc_trace(vbgf2a.samp$samples[,c(acfnodes)], pars = vars(17:32))
mcmc_trace(vbgf2a.samp$samples[,c(acfnodes)], pars = vars(33:48))
mcmc_trace(vbgf2a.samp$samples[,c(acfnodes)], pars = vars(49:64))

#gelman.diag(vbgf1a.samp$samples[1:2,])
effectiveSize(vbgf2a.samp$samples)

# vbgf1a.samp$samples %>%
#   gather_draws(klt[spat.unit,par]) %>%
#   #mutate(val = exp(.value)) %>%
#   ggplot() + 
#   geom_density(aes(x = .value, color = factor(par))) + # age parameter 
#   facet_wrap(par~spat.unit, scales = "free", nrow = 3) +
#   theme_light() 
```

### 3a. Temporal model

Switching the spatial varaibel to a temporal variable. Including NA-sex (despite taking time to run). We get one vbgf param per year and sex.

```{r}
sallaa2 %>% 
  drop_na(sex) %>%
  summarise(l_mean = mean(length, na.rm = T),
            l_sd = sd(length, na.rm = T),
            .by = c(sex, year)) %>%
  ggplot() +
  geom_line(aes(year, l_mean, color = sex)) +
  geom_ribbon(aes(x = year,y = l_mean,ymin = l_mean-l_sd, ymax = l_mean+l_sd, fill = sex), alpha = 0.2) 

sallaa2 %>% 
  count(year,sex) # ~30% NA

sallaa2 %>% 
  ggplot() +
  geom_density(aes(x = length, fill = factor(sex)), alpha = 0.5) +
  #geom_histogram(aes(x = length)) +
  facet_wrap(~spat.unit, scales = "free")
```

```{r}
vbgf3a.code <- nimbleCode({
  # likelihood
  for(i in 1:nobs){
    length[i] ~ dnorm(mu[i], sd = sigma)
    mu[i] <- (klt[year[i],1] + b1[year[i]]*sex[i]) *
      (1-exp(-(klt[year[i],2] + b2[year[i]]*sex[i]) * (age.tot[i]-klt[year[i],3])))
  }
  
  for(k in 1:nobs){
    sex[k]~dbern(psex[1]) #sex coded as 0 or 1
    #sex[k]~dbern(psex[])
    #psex[k] <- age[k] ... length[k] # add
  }
  psex[1] ~ dbeta(mean = 0.6, sd = 0.2)  #prop of males (prob to be 1)
  psex[2] <- 1-psex[1]
    
  # Priors 
  sigma ~ dunif(0, 250)
  
  # LKJ prior on correlation matrix, see NIMBLE manual p45.
  Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3
  U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_klt[1:npars])
  
  for(j in 1:nyear){
   klt[j, 1:npars] ~ dmnorm(mu_klt[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0)
    
   b1[j] ~ dnorm(mub1, sd = sb1)
   b2[j] ~ dnorm(mub2, sd = sb2)
  }
  
  # mu and 2*sd from fishbase
  mu_klt[1] ~ dnorm(1378, sd = 2*139) 
  mu_klt[2] ~ dnorm(0.43, sd = 2*0.28)
  mu_klt[3] ~ dnorm(-1.21, sd = 1.40) 
  # mu and 2*sd from fishbase
  sig_klt[1] ~ dlnorm(log(139),1)
  sig_klt[2] ~ dlnorm(log(0.43),1)
  sig_klt[3] ~ dlnorm(log(1.40),1)

  mub1 ~ dnorm(0, 0.01)
  mub2 ~ dnorm(0, 0.01)
  sb1 ~ dlnorm(0, 1)
  sb2 ~ dlnorm(0, 1)
  
})

# Function creating the Cholesky of the covar. matrix (p45 Nimble manual)
uppertri_mult_diag <- nimbleFunction(
  run = function(mat = double(2), vec = double(1)) {
    returnType(double(2))
    p <- length(vec)
    out <- matrix(nrow = p, ncol = p, init = FALSE)
    for(k in 1:p)
      out[ , k] <- mat[ , k] * vec[k]
    return(out)
   # turn off buildDerivs for the i index
}, buildDerivs = list(run = list(ignore = c('k')))) 

npars <- 3

# initial values generating function
inits <- function(){
  list(mu_klt = c(rnorm(1,1300,140),
                  rnorm(1,0.4,0.3),
                  rnorm(1,-1.2,1.4)),
       mub1 = rnorm(1,100,50),
       mub2 = rnorm(1,0.5,0.5),
       sig_klt = c(rlnorm(1,-0.60,0.30),
                   rlnorm(1,-3,0.05),
                   rlnorm(1,-1,0.05)))}

data <- sallaa2 %>%
  filter(year > 1983) %>%
  mutate(sex = as.integer(if_else(sex == "f", 0, 1)),
         year = as.integer(factor(year))) %>%
  drop_na(sex)

nyear <- length(unique(data$year))

# build model
vbgf3a.model <- nimbleModel(vbgf3a.code,
                        constants = list(npars=npars, 
                                         nyear = nyear, 
                                         nobs = nrow(data), 
                                         year = data$year),
                        inits=inits(),
                        data = data
                        %>% select(age.tot,length,sex),
                        buildDerivs = TRUE)

```

#### Configure, Build & Compile model & HMC

```{r}
# configure hmc
vbgf3a.confhmc <- configureHMC(vbgf3a.model, 
                               monitors = c("klt", "b1", "b2", "Ustar"),
                               enableWAIC = TRUE)

# build mcmc (use buidlHMC() when not using configureHMC())
vbgf3a.hmc <- buildMCMC(vbgf3a.confhmc)

# compile model
vbgf3a.c <- compileNimble(vbgf3a.model)

# compile mcmc  and specify the project model
vbgf3a.hmcc <- compileNimble(vbgf3a.hmc)#, project = vbgf2a.c)

#vbgf2a.c$plotGraph()
# vbgf3a.c$getDependencies(c("sex")) %>%
#   as_tibble() %>%
#   mutate(nodes = str_sub(value, 1, 3)) %>%
#   distinct(nodes)
```

#### HMC Samples
```{r}
#help(NUTS)

vbgf3a.samp <- runMCMC(vbgf3a.hmcc, niter = 5000, nburnin = 4000, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC=TRUE)
```

#### Check/plot samples

```{r}
samp <- vbgf3a.samp
summary(samp$samples)

samp$samples %>%
  gather_draws(b1[year], sep = ",") %>%
  median_qi() %>%
  ggplot() +
  geom_point(aes(x = year, y = .value))#, color = factor(year))) + # age parameter i
  facet_wrap(year~., scales = "free") 
  
# Autocorrelation plots
samp$samples %>%
  autocorr.diag(lags = seq(0,1000,5)) %>%
  as_tibble(rownames = "lag") %>%
  pivot_longer(cols = contains("klt"), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() +

samp$samples %>%
  autocorr.diag(lags = seq(0,1000,5)) %>%
  as_tibble(rownames = "lag") %>%
  # drop the 0 valued Ustar variables (NaN corrs)
  select_if(~!any(is.na(.))) %>%
  pivot_longer(cols = c(!contains("klt"), -lag), names_to = "node" , values_to = "corr") %>%
  mutate(#node = str_replace_all(node, c("\\[" = "", "\\]"="", "," = "_", " "="")),
          lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() 

# Trace plots
# number of plots in each frame
pn = 16
# number of nodes
n = ncol(as.matrix(samp$samples$chain1))

color_scheme_set("viridis")
# loop trace through nodes
for(i in seq(0, n, by = pn)){
  m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn) 
  print(mcmc_trace(e.vbgf1b.samp, pars = vars(i:m)))
}

gelman.diag(vbgf2a.samp$samples)
effectiveSize(samp$samples)

# vbgf1a.samp$samples %>%
#   gather_draws(klt[spat.unit,par]) %>%
#   #mutate(val = exp(.value)) %>%
#   ggplot() + 
#   geom_density(aes(x = .value, color = factor(par))) + # age parameter 
#   facet_wrap(par~spat.unit, scales = "free", nrow = 3) +
#   theme_light() 
```

#### Plot pars

The estimate of Linf is also very large. I guess this is also why b1 is very large.

```{r}
samp$samples %>%
  spread_draws(klt[year, pars], sep = ",") %>%
  median_qi() %>%
  ggplot() + 
  geom_density(aes(x = klt, color = factor(pars))) + # age parameter i
  facet_wrap(~pars, scales = "free") +
  theme_light() +

samp$samples %>%
  gather_draws(b1[year], b2[year], sep = ",") %>%
  median_qi() %>%
  ggplot() + 
  geom_density(aes(x = .value, color = factor(.variable))) + # age parameter i
  facet_wrap(~.variable, scales = "free") +
  theme_light()

samp$samples %>%
  gather_draws(klt[year, pars], sep = ",") %>%
  mutate(pars = if_else(pars == 1, "Linf",
                        if_else(pars == 2,"k","t0"))) %>%
  median_qi() %>%
  ggplot() +
  geom_point(aes(x = year, y = .value, color = factor(pars))) +
  geom_line(aes(x = year, y = .value, color = factor(pars)), alpha = 0.3) +
  facet_wrap(~pars, scales = "free") 
  
samp$samples %>%
  spread_draws(b1[year], klt[year, pars], sep = ",") %>%
  # unite(var, c(".variable","pars", ), na.rm = TRUE) %>%
  filter(pars %in% c(1), 
         #year > 20
         ) %>%
  mutate(m = klt + b1*1,
         f = klt + b1*0) %>%
  median_qi() %>%
  pivot_longer(cols = c("klt", "klt_m"), names_to = "par", values_to = "value") %>%
  ggplot() +
  geom_point(aes(x = year, y = value, color = factor(par))) +
  geom_line(aes(x = year, y = value, color = factor(par)), alpha = 0.3) +
  facet_wrap(~pars, scales = "free") +
  
samp$samples %>%
  spread_draws(b2[year], klt[year, pars], sep = ",") %>%
  filter(pars %in% c(2),
         #year > 20
         ) %>%
  mutate(klt_m = klt + b2*1) %>%
  median_qi() %>%
  pivot_longer(cols = c("klt", "klt_m"), names_to = "par", values_to = "value") %>%
  ggplot() +
  geom_point(aes(x = year, y = value, color = factor(par))) +
  geom_line(aes(x = year, y = value, color = factor(par)), alpha = 0.3) +
  facet_wrap(~pars, scales = "free") 

  # left_join(expand_grid(sex = as.integer(c("1","2")),
  #                       age = seq(0,12, by = 0.1), 
  #                       year = as.integer(c(1:nyear))), by = c("year", "sex")) %>%
  pivot_longer(id_cols = c("sex", "su", "age"), names_from = par, values_from = c(.lower, .upper, kl)) %>%
  mutate(length = kl_1*(1-exp(-kl_2*(age-kl_3))), 
         length.up = .upper_1*(1-exp(-.upper_2*(age-.upper_3))), 
         length.low = .lower_1*(1-exp(-.lower_2*(age-.lower_3))), 
         .by = c("sex", "su")) %>%
  mutate(sex = if_else(sex == 1, "f", "m"))
```

