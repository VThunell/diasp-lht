---
title: "Salmon fecundity model v1"
author: "Viktor Thunell" 
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    code-fold: true
    code-summary: "Show code"
    page-layout: full
    embed-resources: true
    toc: true
knitr: 
  opts_chunk:
    fig.align: center
    out-width: 80%
editor: source
execute: 
  echo: true
  eval: true
  cache: true
---

## Load libraries

```{r libs}
#| message: false
#| warning: false
#| cache: false

# Load libraries, install if needed
pkgs <- c("tidyverse", "tidylog", "devtools","viridis","nls.multstart", "broom", "patchwork", "coda", "boot", "tidybayes","bayesplot", "nimbleHMC", "here")

# remotes::install_github("nimble-dev/nimble", ref = "devel", subdir = "packages/nimble")

if(length_mm(setdiff(pkgs,rownames(installed.packages()))) > 0){
    install.packages(setdiff(pkgs, rownames(installed.packages())), dependencies = T)
  }

invisible(lapply(pkgs, library, character.only = T))

options(ggplot2.continuous.colour = "viridis")
theme_set(theme_light()) # check why global theme option not working when rendering
# Set path
color_scheme_set("viridis")
home <- here::here()
```

## Read data

```{r}
#| message: false
#| warning: false
#| cache: false

salfec <- readRDS(file = paste0(home,"/data/data-for-2-2/salmon-fec_2025-06-19.RData"))

  #filter out non-aged individuals (~34000 individuals)
  #filter(!(is.na(age.sea) & is.na(age.sm))) #%>% 

```

For now I will use the "both" type only.

```{r}
# Create a new dataset 
# salfec <- salfec %>%
#   filter(age.type == "both")

salfec %>%
  #drop_na(sex) %>%
  ggplot() +
  geom_histogram(aes( x = n.eggs))


salfec %>%
  #drop_na(sex) %>%
  ggplot(aes(length_mm, n.eggs, color = sai_location)) +
  geom_point() +
  facet_wrap(~sai_location) +
salfec %>%
  ggplot(aes(log(length_mm), log(n.eggs), color = sai_location)) +
  geom_point() +
  facet_wrap(~sai_location)

salfec %>%
  ggplot(aes(length_mm, n.eggs, color = sai_location)) +
  geom_point() +
salfec %>%
  ggplot(aes(log(length_mm), log(n.eggs), color = sai_location)) +
  geom_point() 

```

# 

```{r}

# If dropping all inds where both sea and sm age is NA 
salfec %>%
  filter(!is.na(weight_g)) %>%
  ggplot(aes(length_mm, n.eggs, color = sai_location)) +
  geom_point()

#   
# salfec2 %>% 
#   ggplot() + 
#   geom_density(aes(x = length_mm), fill = "deeppink", alpha = 0.5)
#   
# salfec2 %>% 
#   ggplot() +
#   geom_density(aes(x = length_mm, fill = factor(age.tot)), alpha = 0.5) +
#   #geom_histogram(aes(x = length_mm)) +
#   facet_wrap(~age.tot, scales = "free")
```

## 1. Spatial model sex covariate

### a. F = a\*L\^b

Using a multivariate normal prior on VGBF params (LKJ prior). Non sexed individuals (sex = NA which are \~30%, mainly from France) are estimated in the model.

#### Model

```{r}

fec1.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    
    n.eggs[i] ~ dnorm(mu[i], sd = sigma)
    mu[i] <- a[sai_location[i]]*length_mm[i]^b[sai_location[i]]
  
  }

  # priors
  sigma ~ dexp(1/10000)
  
  for(j in 1:nloc){
    a[j] ~ dnorm(0, 1)
    b[j] ~ dnorm(0, 1)
  }
  
})
  
# initial values generating function
# inits <- function(){
#   list(a = rnorm(1,0,1,
#              rnorm(1,0.4,0.3),
#              rnorm(1,-1.2,1.4)),
#        
#        mub1 = rnorm(1,100,50),
#        mub2 = rnorm(1,0.5,0.5),
#        sig_par = c(rlnorm(1,-0.60,0.30),
#                    rlnorm(1,-3,0.05),
#                    rlnorm(1,-1,0.05)))}

data <- salfec %>%
  mutate(sai_location.int = as.integer(factor(sai_location))) %>%
  drop_na(sai_location)

nloc <- length(unique(data$sai_location))
# build model
fec1.model <- nimbleModel(fec1.code,
                        constants = list(nloc = nloc,
                                         nobs = nrow(data),
                                         sai_location = data$sai_location.int),
                        #inits=inits(),
                        data = data %>% select(n.eggs, length_mm),
                        buildDerivs = TRUE)

```

#### Configure, Build & Compile model & HMC

```{r}
# configure hmc
fec1.confhmc <- configureHMC(fec1.model, 
                               monitors = c("a", "b"),
                               enableWAIC = TRUE)
  
# build mcmc (use buidlHMC() when not using configureHMC())
fec1.hmc <- buildMCMC(fec1.confhmc)

# compile model
fec1.c <- compileNimble(fec1.model)

# compile mcmc  and specify the project model
fec1.hmcc <- compileNimble(fec1.hmc)#, project = vbgf2a.c)

```

#### HMC Samples

```{r}
#help(NUTS)

fec1.samp <- runMCMC(fec1.hmcc, niter = 5000, nburnin = 3000, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC=TRUE)

```

#### Check/plot samples

```{r}
samp <- fec1.samp$samples
summary(samp)

#length_mm at age for the inds where sex is assigned by the model.
# data %>%
#   bind_cols(sex2 = samp$sex) %>%
#   filter(row_number() %in% which(is.na(data$sex))) %>%
#   ggplot(aes(age.tot, length_mm, color = factor(sex2))) +
#   geom_point()

# deselect the sex nodes to reduce sample object size
# acfnodes <- colnames(samp$samples$chain1)[-which(
#   str_detect(colnames(samp$samples$chain1), "sex"))]
# samp$samples[,c(acfnodes)]

# Autocorrelation plots
samp %>%
#samp$samples[,c(acfnodes)] %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  pivot_longer(cols = contains("b"), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() +

samp %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  # drop the 0 valued Ustar variables (NaN corrs)
  select_if(~!any(is.na(.))) %>%
  pivot_longer(cols = c(!contains("a"), -lag), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light()

# Trace plots
pn = 16 # number of plots in each frame
n = ncol(as.matrix(samp$chain1)) # number of nodes

# loop trace through nodes
for(i in seq(0, n, by = pn)){
  m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)
  print(mcmc_trace(samp, pars = vars(i:m)))
}

gelman.diag(samp$samples[1:2,])
effectiveSize(samp)

fec1.samp$samples %>%
  gather_draws(a[sai_location], b[sai_location]) %>%
  #filter(!sai_location == 19) %>%
  ggplot() +
  geom_density(aes(x = .value, color = factor(sai_location))) + # age parameter
  facet_wrap(~.variable, scales = "free", nrow = 3) +
  theme_light()
```

```{r}
sai_location.name <- data %>%
  select(sai_location.int, sai_location, lat) %>%
  distinct() 

samp %>%
  spread_draws(a[sai_location.int], b[sai_location.int]) %>%
  # mutate(males = case_when(pars == 1 ~ par + b1,
  #                          pars == 2 ~ par + b2, 
  #                         .default = par),
  #        females = par,
  #        pars = case_when(pars == 1 ~ "Linf",
  #                         pars == 2 ~ "k", 
  #                         pars == 3 ~ "t0")) %>%
  # pivot_longer(cols = c("males", "females"), names_to = "sex", values_to = "value") %>%
  # group_by(sex,emu,pars) %>%
  median_qi() %>%
  left_join(sai_location.name) %>% 
  filter(!is.na(sai_location)) %>%
  expand_grid(length_mm = seq(1, 1300, 0.1)) %>%
  mutate(fecundity = a*length_mm^b, .by = "sai_location" ) %>%
  ggplot() +
  geom_line(aes(y = fecundity, x = length_mm, color = sai_location)) +
  geom_point(data = data, aes(y = n.eggs, x = length_mm, color = sai_location), alpha = 0.5) +
  facet_wrap(~sai_location, scales = "fixed") 
  #scale_shape_manual(values = c(1, 4)) +
  #labs(x = "mean latitudes within emu")
```

### b. log(F) = a + b\*L

Using a multivariate normal prior on VGBF params (LKJ prior). Non sexed individuals (sex = NA which are \~30%, mainly from France) are estimated in the model.

#### Model

```{r}

fec2.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    
    #n.eggs[i] ~ dnorm(mu[i], sd = sigma)
    #log(mu[i]) <- a[sai_location[i]] + b[sai_location[i]]*log(length_mm[i])
    
    log(n.eggs[i]) ~ dnorm(mu[i], sd = sigma) 
    mu[i] <- a[sai_location[i]] + b[sai_location[i]]*length_mm[i]
  }

  # priors
  sigma ~ dexp(1/10000)
  
  for(j in 1:nloc){
    a[j] ~ dlnorm(1, 1)
    b[j] ~ dlnorm(1, 1)
  }
  
})
  
data <- salfec %>%
  mutate(sai_location.int = as.integer(factor(sai_location))) %>%
  drop_na(sai_location)

nloc <- length_mm(unique(data$sai_location))

# build model
fec2.model <- nimbleModel(fec2.code,
                        constants = list(nloc = nloc,
                                         nobs = nrow(data),
                                         sai_location = data$sai_location.int),
                        #inits=inits(),
                        data = data %>% select(n.eggs, length_mm),
                        buildDerivs = TRUE)

```

#### Configure, Build & Compile model & HMC

```{r}
# configure hmc
fec2.confhmc <- configureHMC(fec2.model, 
                               monitors = c("a", "b"),
                               enableWAIC = TRUE)
  
# build mcmc (use buidlHMC() when not using configureHMC())
fec2.hmc <- buildMCMC(fec2.confhmc)

# compile model
fec2.c <- compileNimble(fec2.model)

# compile mcmc  and specify the project model
fec2.hmcc <- compileNimble(fec2.hmc)#, project = vbgf2a.c)

```

#### HMC Samples

```{r}
#help(NUTS)

fec2.samp <- runMCMC(fec2.hmcc, niter = 5000, nburnin = 3000, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC=TRUE)

```

#### Check/plot samples

```{r}
samp <- fec2.samp$samples
summary(samp)

#length_mm at age for the inds where sex is assigned by the model.
# data %>%
#   bind_cols(sex2 = samp$sex) %>%
#   filter(row_number() %in% which(is.na(data$sex))) %>%
#   ggplot(aes(age.tot, length_mm, color = factor(sex2))) +
#   geom_point()

# deselect the sex nodes to reduce sample object size
# acfnodes <- colnames(samp$samples$chain1)[-which(
#   str_detect(colnames(samp$samples$chain1), "sex"))]
# samp$samples[,c(acfnodes)]

# Autocorrelation plots
samp %>%
#samp$samples[,c(acfnodes)] %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  pivot_longer(cols = contains("b"), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() +

samp %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  # drop the 0 valued Ustar variables (NaN corrs)
  select_if(~!any(is.na(.))) %>%
  pivot_longer(cols = c(!contains("par"), -lag), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light()

# Trace plots
pn = 16 # number of plots in each frame
n = ncol(as.matrix(samp$chain1)) # number of nodes

# loop trace through nodes
for(i in seq(0, n, by = pn)){
  m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)
  print(mcmc_trace(samp, pars = vars(i:m)))
}

gelman.diag(samp$samples[1:2,])
effectiveSize(samp)

fec1.samp$samples %>%
  gather_draws(a[sai_location], b[sai_location]) %>%
  filter(sai_location == 19) %>%
  #mutate(val = exp(.value)) %>%
  ggplot() +
  geom_density(aes(x = .value, color = factor(sai_location))) + # age parameter
  facet_wrap(~.variable, scales = "free", nrow = 3) +
  theme_light()
```

```{r}
sai_location.name <- data %>%
  select(sai_location.int, sai_location, lat) %>%
  drop_na(sai_location) %>%
  distinct() 

samp %>%
  spread_draws(a[sai_location.int], b[sai_location.int]) %>%
  # mutate(males = case_when(pars == 1 ~ par + b1,
  #                          pars == 2 ~ par + b2, 
  #                         .default = par),
  #        females = par,
  #        pars = case_when(pars == 1 ~ "Linf",
  #                         pars == 2 ~ "k", 
  #                         pars == 3 ~ "t0")) %>%
  # pivot_longer(cols = c("males", "females"), names_to = "sex", values_to = "value") %>%
  # group_by(sex,emu,pars) %>%
  median_qi() %>%
  left_join(sai_location.name) %>% 
  filter(!is.na(sai_location)) %>%
  expand_grid(length_mm = seq(1, 1300, 0.1)) %>%
  mutate(fecundity = exp(a+log(length_mm)*b), .by = "sai_location" ) %>%
  ggplot() +
  geom_line(aes(y = fecundity, x = length_mm, color = sai_location)) +
  geom_point(data = data, aes(y = n.eggs, x = length_mm, color = sai_location), alpha = 0.5) +
  facet_wrap(~sai_location, scales = "fixed") 
  #scale_shape_manual(values = c(1, 4)) +
  #labs(x = "mean latitudes within emu")
```

# Compare WAIC of the exp and log-lin models
```{r}
c(fec1.samp$WAIC, fec2.samp$WAIC)

```

### c. poisson log(F) = a + b\*L

Using a multivariate normal prior on VGBF params (LKJ prior). Non sexed individuals (sex = NA which are \~30%, mainly from France) are estimated in the model.

#### Model

```{r}

fec3.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    
    n.eggs[i] ~ dpois(lam[i])
    log(lam[i]) <- a[sai_location[i]] + log(length_mm[i])*b[sai_location[i]]
  
  }

  # priors
  #sigma ~ dexp(1/10000)
  
  for(j in 1:nloc){
    a[j] ~ dnorm(0, 1)
    b[j] ~ dnorm(0, 1)
  }
  
})
  
data <- salfec %>%
  mutate(sai_location.int = as.integer(factor(sai_location))) %>%
  drop_na(sai_location)

nloc <- length_mm(unique(data$sai_location))

# build model
fec3.model <- nimbleModel(fec3.code,
                        constants = list(nloc = nloc,
                                         nobs = nrow(data),
                                         sai_location = data$sai_location.int),
                        #inits=inits(),
                        data = data %>% select(n.eggs, length_mm),
                        buildDerivs = TRUE)

```

#### Configure, Build & Compile model & HMC

```{r}
# configure hmc
fec3.confhmc <- configureHMC(fec3.model, 
                               monitors = c("a", "b"),
                               enableWAIC = TRUE)
  
# build mcmc (use buidlHMC() when not using configureHMC())
fec3.hmc <- buildMCMC(fec3.confhmc)

# compile model
fec3.c <- compileNimble(fec3.model)

# compile mcmc  and specify the project model
fec3.hmcc <- compileNimble(fec3.hmc)#, project = vbgf2a.c)

```

#### HMC Samples

```{r}
#help(NUTS)

fec3.samp <- runMCMC(fec3.hmcc, niter = 5000, nburnin = 3000, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC=TRUE)

```

#### Check/plot samples

```{r}
c(fec2.samp$WAIC, fec3.samp$WAIC)
```


```{r}
samp <- fec3.samp$samples
summary(samp)

#length_mm at age for the inds where sex is assigned by the model.
# data %>%
#   bind_cols(sex2 = samp$sex) %>%
#   filter(row_number() %in% which(is.na(data$sex))) %>%
#   ggplot(aes(age.tot, length_mm, color = factor(sex2))) +
#   geom_point()

# deselect the sex nodes to reduce sample object size
# acfnodes <- colnames(samp$samples$chain1)[-which(
#   str_detect(colnames(samp$samples$chain1), "sex"))]
# samp$samples[,c(acfnodes)]

# Autocorrelation plots
samp %>%
#samp$samples[,c(acfnodes)] %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  pivot_longer(cols = contains("b"), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() +

samp %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  # drop the 0 valued Ustar variables (NaN corrs)
  select_if(~!any(is.na(.))) %>%
  pivot_longer(cols = c(!contains("par"), -lag), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light()

# Trace plots
pn = 16 # number of plots in each frame
n = ncol(as.matrix(samp$chain1)) # number of nodes

# loop trace through nodes
for(i in seq(0, n, by = pn)){
  m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)
  print(mcmc_trace(samp, pars = vars(i:m)))
}

gelman.diag(samp$samples[1:2,])
effectiveSize(samp)

fec1.samp$samples %>%
  gather_draws(a[sai_location], b[sai_location]) %>%
  filter(sai_location == 19) %>%
  #mutate(val = exp(.value)) %>%
  ggplot() +
  geom_density(aes(x = .value, color = factor(sai_location))) + # age parameter
  facet_wrap(~.variable, scales = "free", nrow = 3) +
  theme_light()
```

## 2. Adding explanatory variables

### a. F = a\*L\^b

Using a multivariate normal prior on VGBF params (LKJ prior). Non sexed individuals (sex = NA which are \~30%, mainly from France) are estimated in the model.

#### Model

```{r}

fec4.code <- nimbleCode({
  
  # likelihood
  for(i in 1:nobs){
    
    n.eggs[i] ~ dnorm(mu[i], sd = sigma)
    mu[i] <- a[sai_location[i]]*length_mm[i]^b[sai_location[i]] + c[sai_location[i]]*weight_g[i]
  
  }

  # priors
  sigma ~ dexp(1/10000)
  
  for(j in 1:nloc){
    a[j] ~ dnorm(0, 1)
    b[j] ~ dnorm(0, 1)
    c[j] ~ dnorm(0, 1)
  }
  
})
  
# initial values generating function
# inits <- function(){
#   list(a = rnorm(1,0,1,
#              rnorm(1,0.4,0.3),
#              rnorm(1,-1.2,1.4)),
#        
#        mub1 = rnorm(1,100,50),
#        mub2 = rnorm(1,0.5,0.5),
#        sig_par = c(rlnorm(1,-0.60,0.30),
#                    rlnorm(1,-3,0.05),
#                    rlnorm(1,-1,0.05)))}

data <- salfec %>%
  mutate(sai_location.int = as.integer(factor(sai_location))) %>%
  drop_na(sai_location, weight_g)

nloc <- length_mm(unique(data$sai_location))
# build model
fec4.model <- nimbleModel(fec4.code,
                        constants = list(nloc = nloc,
                                         nobs = nrow(data),
                                         sai_location = data$sai_location.int),
                        #inits=inits(),
                        data = data %>% select(n.eggs, length_mm, weight_g),
                        buildDerivs = TRUE)

```

#### Configure, Build & Compile model & HMC

```{r}
# configure hmc
fec4.confhmc <- configureHMC(fec4.model, 
                               monitors = c("a", "b"),
                               enableWAIC = TRUE)
  
# build mcmc (use buidlHMC() when not using configureHMC())
fec4.hmc <- buildMCMC(fec4.confhmc)

# compile model
fec4.c <- compileNimble(fec4.model)

# compile mcmc  and specify the project model
fec4.hmcc <- compileNimble(fec4.hmc)#, project = vbgf2a.c)

```

#### HMC Samples

```{r}
#help(NUTS)

fec4.samp <- runMCMC(fec4.hmcc, niter = 5000, nburnin = 3000, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC=TRUE)

```

#### Check/plot samples

```{r}
samp <- fec1.samp$samples
summary(samp)

#length_mm at age for the inds where sex is assigned by the model.
# data %>%
#   bind_cols(sex2 = samp$sex) %>%
#   filter(row_number() %in% which(is.na(data$sex))) %>%
#   ggplot(aes(age.tot, length_mm, color = factor(sex2))) +
#   geom_point()

# deselect the sex nodes to reduce sample object size
# acfnodes <- colnames(samp$samples$chain1)[-which(
#   str_detect(colnames(samp$samples$chain1), "sex"))]
# samp$samples[,c(acfnodes)]

# Autocorrelation plots
samp %>%
#samp$samples[,c(acfnodes)] %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  pivot_longer(cols = contains("b"), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light() +

samp %>%
  autocorr.diag(lags = seq(0,500,1)) %>%
  as_tibble(rownames = "lag") %>%
  # drop the 0 valued Ustar variables (NaN corrs)
  select_if(~!any(is.na(.))) %>%
  pivot_longer(cols = c(!contains("a"), -lag), names_to = "node" , values_to = "corr") %>%
  mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>%
  ggplot() +
  geom_bar(aes(x = lag, y = corr), stat = "identity") +
  facet_wrap(~node) +
  theme_light()

# Trace plots
pn = 16 # number of plots in each frame
n = ncol(as.matrix(samp$chain1)) # number of nodes

# loop trace through nodes
for(i in seq(0, n, by = pn)){
  m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn)
  print(mcmc_trace(samp, pars = vars(i:m)))
}

gelman.diag(samp$samples[1:2,])
effectiveSize(samp)

fec1.samp$samples %>%
  gather_draws(a[sai_location], b[sai_location]) %>%
  #filter(!sai_location == 19) %>%
  ggplot() +
  geom_density(aes(x = .value, color = factor(sai_location))) + # age parameter
  facet_wrap(~.variable, scales = "free", nrow = 3) +
  theme_light()
```



<!-- #### Fixing checks -->

<!-- ```{r} -->
<!-- fec2.model$getDependencies(c("n.eggs")) -->
<!-- fec2.model$getNodeNames()[1000:1961] -->
<!-- fec2.model$initializeInfo() -->
<!-- fec2.model$getVarNames() -->
<!-- fec2.model$simulate("sigma") -->
<!-- fec2.model$simulate("a") -->
<!-- fec2.model$simulate("b") -->
<!-- fec2.model$b -->
<!-- fec2.model$a -->
<!-- fec2.model$sigma -->
<!-- fec2.model$simulate("mu") -->
<!-- fec2.model$mu -->
<!-- fec2.model$mu[1000:1461] -->
<!-- fec2.model$n.eggs -->
<!-- fec2.model$length_mm -->

<!-- ``` -->

<!-- #### Configure, Build & Compile model & HMC -->

<!-- ```{r} -->

<!-- # configure hmc -->

<!-- fec1.confhmc <- configureHMC(fec1.model,  -->

<!--                                monitors = c("par", "P", "Ustar"), -->

<!--                                enableWAIC = TRUE) -->

<!-- # build mcmc (use buidlHMC() when not using configureHMC()) -->

<!-- fec1.hmc <- buildMCMC(fec1.confhmc) -->

<!-- # compile model -->

<!-- fec1.c <- compileNimble(fec1.model) -->

<!-- # compile mcmc  and specify the project model -->

<!-- fec1.hmcc <- compileNimble(fec1.hmc) -->

<!-- ``` -->

<!-- #### HMC Samples -->

<!-- ```{r} -->

<!-- #help(NUTS) -->

<!-- fec1.samp <- runMCMC(fec1.hmcc, niter = 2000, nburnin = 1000, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC = TRUE) -->

<!-- #vbgf2a.samp <- readRDS(file = paste0(home,"/vbgf2a.samp_20250517")) -->

<!-- ``` -->

<!-- #### Check/plot samples -->

<!-- ```{r} -->

<!-- samp <- fec1.samp$samples -->

<!-- summary(samp) -->

<!-- # Autocorrelation plots -->

<!-- samp %>% -->

<!--   autocorr.diag(lags = seq(0,500,1)) %>% -->

<!--   as_tibble(rownames = "lag") %>% -->

<!--   pivot_longer(cols = contains("par"), names_to = "node" , values_to = "corr") %>% -->

<!--   mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>% -->

<!--   ggplot() + -->

<!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + -->

<!--   facet_wrap(~node) + -->

<!--   theme_light() + -->

<!-- samp %>% -->

<!--   autocorr.diag(lags = seq(0,500,1)) %>% -->

<!--   as_tibble(rownames = "lag") %>% -->

<!--   # drop the 0 valued Ustar variables (NaN corrs) -->

<!--   select_if(~!any(is.na(.))) %>% -->

<!--   pivot_longer(cols = c(!contains("par"), -lag), names_to = "node" , values_to = "corr") %>% -->

<!--   mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>% -->

<!--   ggplot() + -->

<!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + -->

<!--   facet_wrap(~node) + -->

<!--   theme_light() -->

<!-- # Trace plots -->

<!-- mcmc_trace(samp) -->

<!-- gelman.diag(samp) -->

<!-- effectiveSize(samp) -->

<!-- samp %>% -->

<!--   gather_draws(par[n]) %>% -->

<!--   #mutate(val = exp(.value)) %>% -->

<!--   ggplot() + -->

<!--   geom_density(aes(x = .value, color = factor(n)))  +# age parameter -->

<!--   facet_wrap(~n, scales = "free", nrow = 3) + -->

<!--   theme_light()  -->

<!-- samp %>% -->

<!--   gather_draws(P) %>% -->

<!--   #mutate(val = exp(.value)) %>% -->

<!--   ggplot() + -->

<!--   geom_density(aes(x = .value))  + -->

<!--   theme_light() -->

<!-- ``` -->

<!-- ```{r} -->

<!-- samp %>% -->

<!--   gather_draws(par[np], P) %>% -->

<!--   median_qi() %>% -->

<!--   mutate(par = case_when(np == 1 ~ "L1", -->

<!--                          np == 2 ~ "L2", -->

<!--                          np == 3 ~ "K", -->

<!--                          .variable == "P" ~ "p"))  %>% -->

<!--   select(par, .value) %>% -->

<!--   pivot_wider(names_from = par, values_from = .value) %>% -->

<!--   expand_grid(age = seq(A1, A2, 1)) %>% -->

<!--   #rename(L1 = 1, p = 2, L2 = 3, K = 4) %>% -->

<!--   mutate(length_mm = (L1^p + (L2^p - L1^p) *  -->

<!--          (1 - exp(-K*(age-A1))) / (1 - exp(-K*(A2-A1))) )^(1/p) ) %>% -->

<!--   ggplot() + -->

<!--   geom_point(data = data, aes(age.tot, length_mm), alpha = 0.1, color = "lightblue") + -->

<!--   geom_line(aes(age, length_mm)) + -->

<!--   theme_light() + -->

<!--   labs(title = "fecte") -->

<!-- ``` -->

<!-- ### c. WAIC and correlatiopns of vbgf vs fecte -->

<!-- WAIC of the fecte is higher than that of the VBGF. -->

<!-- ```{r} -->

<!-- print("VBGF") -->

<!-- vbgf1.samp$WAIC -->

<!-- print("1-Linf, 2-K, 3-t0") -->

<!-- samp <- vbgf1.samp$samples -->

<!-- s = nrow(samp$chain1) -->

<!-- cols <- grep("^Ustar",colnames(as.matrix(samp))) -->

<!-- Ustar_sample <- matrix(samp$chain1[s, cols], npars, npars) -->

<!-- crossprod(Ustar_sample)  ## i.e., t(Ustar_sample) %*% Ustar_sample -->

<!-- print("fecte") -->

<!-- fec1.samp$WAIC -->

<!-- print("1-L1, 2-L2, 3-K") -->

<!-- samp <- fec1.samp$samples -->

<!-- s = nrow(samp$chain1) -->

<!-- cols <- grep("^Ustar",colnames(as.matrix(samp))) -->

<!-- Ustar_sample <- matrix(samp$chain1[s, cols], npars, npars) -->

<!-- crossprod(Ustar_sample)  ## i.e., t(Ustar_sample) %*% Ustar_sample -->

<!-- ``` -->

<!-- ## 2. Spatial model sex covariate -->

<!-- ### a. von Bertalanffy -->

<!-- Using a multivariate normal prior on VGBF params (LKJ prior). Non sexed individuals (sex = NA which are ~30%, mainly from France) are estimated in the model. -->

<!-- #### Model -->

<!-- ```{r} -->

<!-- vbgf2a.code <- nimbleCode({ -->

<!--   # likelihood -->

<!--   for(i in 1:nobs){ -->

<!--     length_mm[i] ~ dnorm(mu[i], sd = sigma) -->

<!--     mu[i] <- (par[spat.unit[i],1] + b1[spat.unit[i]]*sex[i]) * -->

<!--       (1-exp(-(par[spat.unit[i],2] + b2[spat.unit[i]]*sex[i]) * (age.tot[i]-par[spat.unit[i],3]))) -->

<!--   } -->

<!--   # estimate sex -->

<!--   for(k in 1:nobs){ -->

<!--     sex[k]~dbern(psex[1]) -->

<!--   } -->

<!--   psex[1] ~ dbeta(mean = 0.5, sd = 0.2)  #prop of males (prob to be 1) -->

<!--   psex[2] <- 1-psex[1] -->

<!--   # priors -->

<!--   sigma ~ dunif(0, 250) -->

<!--   # LKJ prior on correlation matrix, see NIMBLE manual p45. -->

<!--   Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3 -->

<!--   U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars]) -->

<!--   for(j in 1:nsu){ -->

<!--    par[j, 1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0) -->

<!--    b1[j] ~ dnorm(mub1, sd = sb1) -->

<!--    b2[j] ~ dnorm(mub2, sd = sb2) -->

<!--   } -->

<!--   # mu and 2*sd from fishbase -->

<!--   mu_par[1] ~ dnorm(1378, sd = 2*139) -->

<!--   mu_par[2] ~ dnorm(0.43, sd = 2*0.28) -->

<!--   mu_par[3] ~ dnorm(-1.21, sd = 1.40) -->

<!--   # mu and 2*sd from fishbase -->

<!--   sig_par[1] ~ dlnorm(log(139),1) -->

<!--   sig_par[2] ~ dlnorm(log(0.43),1) -->

<!--   sig_par[3] ~ dlnorm(log(1.40),1) -->

<!--   mub1 ~ dnorm(0, 0.01) -->

<!--   mub2 ~ dnorm(0, 0.01) -->

<!--   sb1 ~ dlnorm(0, 1) -->

<!--   sb2 ~ dlnorm(0, 1) -->

<!-- }) -->

<!-- # Function creating the Cholesky of the covar. matrix (p45 Nimble manual) -->

<!-- uppertri_mult_diag <- nimbleFunction( -->

<!--   run = function(mat = double(2), vec = double(1)) { -->

<!--     returnType(double(2)) -->

<!--     p <- length_mm(vec) -->

<!--     out <- matrix(nrow = p, ncol = p, init = FALSE) -->

<!--     for(k in 1:p) -->

<!--       out[ , k] <- mat[ , k] * vec[k] -->

<!--     return(out) -->

<!--    # turn off buildDerivs for the i index -->

<!-- }, buildDerivs = list(run = list(ignore = c('k')))) -->

<!-- npars <- 3 -->

<!-- nsu <- length_mm(unique(sallaa$spat.unit)) -->

<!-- # initial values generating function -->

<!-- inits <- function(){ -->

<!--   list(mu_par = c(rnorm(1,1300,140), -->

<!--                   rnorm(1,0.4,0.3), -->

<!--                   rnorm(1,-1.2,1.4)), -->

<!--        mub1 = rnorm(1,100,50), -->

<!--        mub2 = rnorm(1,0.5,0.5), -->

<!--        sig_par = c(rlnorm(1,-0.60,0.30), -->

<!--                    rlnorm(1,-3,0.05), -->

<!--                    rlnorm(1,-1,0.05)))} -->

<!-- data <- sallaa %>% -->

<!--   mutate(sex = as.integer(if_else(sex == "f", 0, 1)), -->

<!--          spat.unit = as.integer(factor(sallaa$spat.unit))) %>% -->

<!--   filter(age.type == "both") -->

<!-- # build model -->

<!-- vbgf2a.model <- nimbleModel(vbgf2a.code, -->

<!--                         constants = list(npars=npars, -->

<!--                                          nsu = nsu, -->

<!--                                          nobs = nrow(data), -->

<!--                                          spat.unit = data$spat.unit), -->

<!--                         inits=inits(), -->

<!--                         data = data -->

<!--                         %>% select(age.tot,length_mm,sex), -->

<!--                         buildDerivs = TRUE) -->

<!-- ``` -->

<!-- #### Configure, Build & Compile model & HMC -->

<!-- ```{r} -->

<!-- # configure hmc -->

<!-- vbgf2a.confhmc <- configureHMC(vbgf2a.model, -->

<!--                                monitors = c("par", "b1", "b2", "Ustar"), -->

<!--                                enableWAIC = TRUE) -->

<!-- # build mcmc (use buidlHMC() when not using configureHMC()) -->

<!-- vbgf2a.hmc <- buildMCMC(vbgf2a.confhmc) -->

<!-- # compile model -->

<!-- vbgf2a.c <- compileNimble(vbgf2a.model) -->

<!-- # the nodes that depend on sex -->

<!-- # vbgf2a.c$getDependencies(c("sex")) %>% -->

<!-- #   as_tibble() %>% -->

<!-- #   mutate(nodes = str_extract(value, "\\w+")) %>% -->

<!-- #   distinct(nodes) -->

<!-- # compile mcmc  and specify the project model -->

<!-- vbgf2a.hmcc <- compileNimble(vbgf2a.hmc)#, project = vbgf2a.c) -->

<!-- ``` -->

<!-- #### HMC Samples -->

<!-- ```{r} -->

<!-- #help(NUTS) -->

<!-- vbgf2a.samp <- runMCMC(vbgf2a.hmcc, niter = 5000, nburnin = 3000, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC=TRUE) -->

<!-- #vbgf2a.samp <- readRDS(file = paste0(home,"/vbgf2a.samp_20250517")) -->

<!-- ``` -->

<!-- #### Check/plot samples -->

<!-- ```{r} -->

<!-- samp <- vbgf2a.samp$samples -->

<!-- summary(vbgf2a.samp$samples) -->

<!-- # length_mm at age for the inds where sex is assigned by the model. -->

<!-- data %>% -->

<!--   bind_cols(sex2 = vbgf2a.c$sex) %>% -->

<!--   filter(row_number() %in% which(is.na(data$sex))) %>% -->

<!--   ggplot(aes(age.tot, length_mm, color = factor(sex2))) + -->

<!--   geom_point() -->

<!-- # deselect the sex nods to reduce sample object size -->

<!-- acfnodes <- colnames(vbgf2a.samp$samples$chain1)[-which( -->

<!--   str_detect(colnames(vbgf2a.samp$samples$chain1), "sex"))] -->

<!-- vbgf2a.samp$samples[,c(acfnodes)] -->

<!-- # Autocorrelation plots -->

<!-- vbgf2a.samp$samples[,c(acfnodes)] %>% -->

<!--   autocorr.diag(lags = seq(0,500,1)) %>% -->

<!--   as_tibble(rownames = "lag") %>% -->

<!--   pivot_longer(cols = contains("par"), names_to = "node" , values_to = "corr") %>% -->

<!--   mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>% -->

<!--   ggplot() + -->

<!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + -->

<!--   facet_wrap(~node) + -->

<!--   theme_light() + -->

<!-- vbgf2a.samp$samples[,c(acfnodes)] %>% -->

<!--   autocorr.diag(lags = seq(0,500,1)) %>% -->

<!--   as_tibble(rownames = "lag") %>% -->

<!--   # drop the 0 valued Ustar variables (NaN corrs) -->

<!--   select_if(~!any(is.na(.))) %>% -->

<!--   pivot_longer(cols = c(!contains("par"), -lag), names_to = "node" , values_to = "corr") %>% -->

<!--   mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>% -->

<!--   ggplot() + -->

<!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + -->

<!--   facet_wrap(~node) + -->

<!--   theme_light() -->

<!-- # Trace plots -->

<!-- pn = 16 # number of plots in each frame -->

<!-- n = ncol(as.matrix(samp$chain1)) # number of nodes -->

<!-- # loop trace through nodes -->

<!-- for(i in seq(0, n, by = pn)){ -->

<!--   m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn) -->

<!--   print(mcmc_trace(samp, pars = vars(i:m))) -->

<!-- } -->

<!-- gelman.diag(vbgf1a.samp$samples[1:2,]) -->

<!-- effectiveSize(vbgf2a.samp$samples) -->

<!-- samp %>% -->

<!--   gather_draws(par[spat.unit,pars], sep = ",") %>% -->

<!--   mutate(pars = case_when(pars == 1 ~ "Linf", -->

<!--                          pars == 2 ~ "K", -->

<!--                          pars == 3 ~ "t0")) %>% -->

<!--   ggplot() + -->

<!--   geom_density(aes(x = .value, color = factor(spat.unit))) + -->

<!--   facet_wrap(~pars, scales = "free") + -->

<!--   theme_light() -->

<!-- samp %>% -->

<!--   gather_draws(b1[spat.unit], b2[spat.unit], sep = ",") %>% -->

<!--   mutate(.variable = case_when(.variable == "b1" ~ "b_Linf", -->

<!--                          .variable == "b2" ~ "b_K")) %>% -->

<!--   ggplot() + -->

<!--   geom_density(aes(x = .value, color = factor(spat.unit))) + -->

<!--   facet_wrap(~.variable, scales = "free") + -->

<!--   theme_light() -->

<!-- ``` -->

<!-- #### shape of the VGBF by su -->

<!-- ```{r} -->

<!-- samp %>% -->

<!--   spread_draws(b1, b2, par[emu, pars], sep = ",") %>% -->

<!--   mutate(males = case_when(pars == 1 ~ par + b1, -->

<!--                            pars == 2 ~ par + b2,  -->

<!--                           .default = par), -->

<!--          females = par, -->

<!--          pars = case_when(pars == 1 ~ "Linf", -->

<!--                           pars == 2 ~ "k",  -->

<!--                           pars == 3 ~ "t0")) %>% -->

<!--   pivot_longer(cols = c("males", "females"), names_to = "sex", values_to = "value") %>% -->

<!--   group_by(sex,emu,pars) %>% -->

<!--   median_qi() %>% -->

<!--   left_join(emu.name %>% summarise(my=mean(ser_y, na.rm = TRUE), .by=c(emu,ser_emu_nameshort))) %>%  -->

<!--   ggplot() + -->

<!--   geom_pointinterval(aes(y = value, x = my, ymin = value.lower,  -->

<!--              ymax = value.upper, color = ser_emu_nameshort,  -->

<!--              shape = sex), size = 0.8, alpha = 0.5, linewidth = 0.01) + -->

<!--   facet_wrap(~pars, ncol = 3) +#, scales = "free") + -->

<!--   scale_shape_manual(values = c(1, 4)) + -->

<!--   labs(x = "mean latitudes within emu") -->

<!-- ``` -->

<!-- ### b. fecte -->

<!-- #### Model -->

<!-- ```{r} -->

<!-- fec2.code <- nimbleCode({ -->

<!--   # likelihood -->

<!--   for(i in 1:nobs){ -->

<!--     length_mm[i] ~ dnorm(mu[i], sd = sigma) -->

<!--     # + bL1[su[i]]*sex[i] -->

<!--     # + bK[su[i]]*sex[i] -->

<!--     # + bK[su[i]]*sex[i] -->

<!--     mu[i] <- ( par[su[i],1]^P[su[i]] + (par[su[i],2]^P[su[i]] - par[su[i],1]^P[su[i]]) * ( (1-exp(-par[su[i],3]*(age.tot[i]-A1))) / (1-exp(-par[su[i],3]*(A2-A1))) ) )^(1/P[su[i]]) -->

<!--   #   u[i] <- (par[spat.unit[i],1] + b1[spat.unit[i]]*sex[i]) * -->

<!--   #     (1-exp(-(par[spat.unit[i],2] + b2[spat.unit[i]]*sex[i]) * (age.tot[i]-par[spat.unit[i],3]))) -->

<!--     } -->

<!--   # Priors  -->

<!--   sigma ~ dunif(0, 250) -->

<!--   # LKJ prior on correlation matrix, see NIMBLE manual p45. -->

<!--   Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3 -->

<!--   U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars]) -->

<!--   for(j in 1:nsu){ -->

<!--     par[j, 1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0) -->

<!--     P[j] ~ dnorm(-1, 0.5) -->

<!--    #b1[j] ~ dnorm(mub1, sd = sb1) -->

<!--    #b2[j] ~ dnorm(mub2, sd = sb2) -->

<!--   } -->

<!--   mu_par[1] ~ dnorm(100, sd = 50) # L1 -->

<!--   mu_par[2] ~ dnorm(1300, sd = 100) # L2 -->

<!--   mu_par[3] ~ dnorm(0.43, sd = 0.4) # K -->

<!--   sig_par[1] ~ dexp(1/(50/4)) -->

<!--   sig_par[2] ~ dexp(1/(100/4)) -->

<!--   sig_par[3] ~ dexp(1/(0.4/4)) -->

<!--   # # Calculate Linf and K -->

<!--   #Linf  <- ( (exp(par[1]*A2)*L2^par[2] - (exp(par[1]*A1)*L1^par[2])) / (exp(par[1]*A2) - exp(par[1]*A1)) )^(1/par[1]) -->

<!--   #t0 <- A1 + A2 - (1/par[2])*log(Linf) -->

<!-- }) -->

<!-- # Function creating the Cholesky of the covar. matrix (p45 Nimble manual) -->

<!-- uppertri_mult_diag <- nimbleFunction( -->

<!--   run = function(mat = double(2), vec = double(1)) { -->

<!--     returnType(double(2)) -->

<!--     p <- length_mm(vec) -->

<!--     out <- matrix(nrow = p, ncol = p, init = FALSE) -->

<!--     for(k in 1:p) -->

<!--       out[ , k] <- mat[ , k] * vec[k] -->

<!--     return(out) -->

<!--    # turn off buildDerivs for the i index -->

<!-- }, buildDerivs = list(run = list(ignore = c('k'))))  -->

<!-- # initial values generating function (par[1:4] = L1,p,L2,K) -->

<!-- inits <- function(){ -->

<!--   list(mu_par = c(rnorm(1, 100, 0.01), -->

<!--                   rnorm(1, 1000, 0.01), -->

<!--                   rnorm(1, 0, 0.01)), -->

<!--        P = rnorm(1,-2.5,1), -->

<!--        sig_par = c(rexp(1,1/(50/4)), -->

<!--                    rexp(1,1/(100/4)), -->

<!--                    rexp(1,1/(0.4/4))))} -->

<!-- data <- sallaa %>% -->

<!--   filter(!age.type == "sea.only") %>% -->

<!--   mutate(su = as.integer(factor(spat.unit))) %>% -->

<!--   drop_na(su) -->

<!-- npars <- 3 -->

<!-- A1 <- min(data$age.tot) -->

<!-- A2 <- max(data$age.tot) -->

<!-- # build model -->

<!-- fec2.model <- nimbleModel(fec2.code, -->

<!--                         constants = list(npars=npars, -->

<!--                                          A1 = A1, -->

<!--                                          A2 = A2, -->

<!--                                          nobs = nrow(data), -->

<!--                                          nsu = length_mm(unique(data$su)), -->

<!--                                          su = data$su -->

<!--                                          #constraint_data = 1), -->

<!--                                          ), -->

<!--                         #inits=inits(), -->

<!--                         data = data %>% select(age.tot,length_mm) -->

<!--                         ,buildDerivs = TRUE) -->

<!-- ``` -->

<!-- #### Configure, Build & Compile model & HMC -->

<!-- ```{r} -->

<!-- # configure hmc -->

<!-- fec2.confhmc <- configureHMC(fec2.model,  -->

<!--                                monitors = c("par", "P", "Ustar"), -->

<!--                                enableWAIC = TRUE) -->

<!-- # build mcmc (use buidlHMC() when not using configureHMC()) -->

<!-- fec2.hmc <- buildMCMC(fec2.confhmc) -->

<!-- # compile model -->

<!-- fec2.c <- compileNimble(fec2.model) -->

<!-- # compile mcmc  and specify the project model -->

<!-- fec2.hmcc <- compileNimble(fec2.hmc) -->

<!-- ``` -->

<!-- #### HMC Samples -->

<!-- ```{r} -->

<!-- #help(NUTS) -->

<!-- fec2.samp <- runMCMC(fec2.hmcc, niter = 5000, nburnin = 3000, nchains = 2, samplesAsCodaMCMC = TRUE, WAIC = TRUE) -->

<!-- #vbgf2a.samp <- readRDS(file = paste0(home,"/vbgf2a.samp_20250517")) -->

<!-- ``` -->

<!-- #### Check/plot samples -->

<!-- ```{r} -->

<!-- samp <- fec2.samp$samples -->

<!-- summary(samp) -->

<!-- # Autocorrelation plots -->

<!-- samp %>% -->

<!--   autocorr.diag(lags = seq(0,500,1)) %>% -->

<!--   as_tibble(rownames = "lag") %>% -->

<!--   pivot_longer(cols = contains("par"), names_to = "node" , values_to = "corr") %>% -->

<!--   mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>% -->

<!--   ggplot() + -->

<!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + -->

<!--   facet_wrap(~node) + -->

<!--   theme_light() + -->

<!-- samp %>% -->

<!--   autocorr.diag(lags = seq(0,500,1)) %>% -->

<!--   as_tibble(rownames = "lag") %>% -->

<!--   # drop the 0 valued Ustar variables (NaN corrs) -->

<!--   select_if(~!any(is.na(.))) %>% -->

<!--   pivot_longer(cols = c(!contains("par"), -lag), names_to = "node" , values_to = "corr") %>% -->

<!--   mutate(lag = as.numeric(str_extract(lag, "\\d+"))) %>% -->

<!--   ggplot() + -->

<!--   geom_bar(aes(x = lag, y = corr), stat = "identity") + -->

<!--   facet_wrap(~node) + -->

<!--   theme_light() -->

<!-- # Trace plots -->

<!-- pn = 16 # number of plots in each frame -->

<!-- n = ncol(as.matrix(samp$chain1)) # number of nodes -->

<!-- # loop trace through nodes -->

<!-- for(i in seq(0, n, by = pn)){ -->

<!--   m = if_else(i != pn*( n %/% pn), i+pn, i + n %% pn) -->

<!--   print(mcmc_trace(samp, pars = vars(i:m))) -->

<!-- } -->

<!-- gelman.diag(samp) -->

<!-- effectiveSize(samp) -->

<!-- samp %>% -->

<!--   gather_draws(par[su,np], sep = ",") %>% -->

<!--   #mutate(val = exp(.value)) %>% -->

<!--   ggplot() + -->

<!--   geom_density(aes(x = .value, color = factor(su))) + # age parameter -->

<!--   facet_wrap(~np, scales = "free") + -->

<!--   theme_light() + -->

<!-- samp %>% -->

<!--   gather_draws(P[su], sep = ",") %>% -->

<!--   ggplot() + -->

<!--   geom_density(aes(x = .value, color = factor(su))) + # age parameter -->

<!--   theme_light() -->

<!-- ``` -->

<!-- ```{r} -->

<!-- su.name <- data %>%  -->

<!--   distinct(spat.unit,su) -->

<!-- samp %>% -->

<!--   gather_draws(par[su, np], P[su], sep = ",") %>% -->

<!--   median_qi() %>% -->

<!--   mutate(par = case_when(np == 1 ~ "L1", -->

<!--                          np == 2 ~ "L2", -->

<!--                          np == 3 ~ "K", -->

<!--                          .variable == "P" ~ "p"))  %>% -->

<!--   select(par, .value, su) %>% -->

<!--   pivot_wider(names_from = par, values_from = .value) %>% -->

<!--   expand_grid(age = seq(A1, A2, 0.1)) %>% -->

<!--   mutate(length_mm = (L1^p + (L2^p - L1^p) *  -->

<!--          (1 - exp(-K*(age-A1))) / (1 - exp(-K*(A2-A1))) )^(1/p) ) %>% -->

<!--   left_join(su.name, by = "su") %>% -->

<!--   ggplot() + -->

<!--   geom_line(aes(age, length_mm, color = factor(spat.unit))) + -->

<!--   geom_point(data = data, aes(age.tot, length_mm, color = factor(spat.unit)), alpha = 0.1) + -->

<!--   theme_light() + -->

<!--   facet_wrap(~spat.unit, scales = "free") + -->

<!--   labs(title = "fecte") -->

<!-- ``` -->

<!-- ### c. AIC vbgf vs fecte -->

<!-- ```{r} -->

<!-- fec1.samp$WAIC -->

<!-- vbgf1.samp$WAIC -->

<!-- ``` -->

<!-- ### d. fecte 2b -->

<!-- spatially varying sex effect on P, L2, K. Putting P back into the LKJ as I´m using a normal gain on this.  -->

<!-- ```{r} -->

<!-- fec2b.code <- nimbleCode({ -->

<!--   # likelihood -->

<!--   for(i in 1:nobs){ -->

<!--     length_mm[i] ~ dnorm(mu[i], sd = sigma) -->

<!--     # mu[i] <- ( par[su[i],1]^P[su[i]] + (par[su[i],2]^P[su[i]] - par[su[i],1]^P[su[i]]) * ( (1-exp(-par[su[i],3]*(age.tot[i]-A1))) / (1-exp(-par[su[i],3]*(A2-A1))) ) )^(1/P[su[i]]) -->

<!--     mu[i] <- ( par[su[i],1]^(par[su[i],2] + bP[su[i]]*sex[i]) + ((par[su[i],3] + bL[su[i]]*sex[i])^(par[su[i],2]+ bP[su[i]]*sex[i]) - par[emu[i],1]^(par[su[i],2] + bP[su[i]]*sex[i])) * ( (1-exp(-(par[su[i],4] + bK[su[i]]*sex[i])*(age[i]-A1))) / (1-exp(-(par[su[i],4] + bK[su[i]]*sex[i])*(A2-A1))) ) )^(par[su[i],2]+ bP[su[i]]*sex[i]) -->

<!--     } -->

<!--   # Priors  -->

<!--   sigma ~ dunif(0, 250) -->

<!--   # LKJ prior on correlation matrix, see NIMBLE manual p45. -->

<!--   Ustar[1:npars,1:npars] ~ dlkj_corr_cholesky(1.3, npars) # eta = 1.3 -->

<!--   U[1:npars,1:npars] <- uppertri_mult_diag(Ustar[1:npars, 1:npars], sig_par[1:npars]) -->

<!--   for(j in 1:nsu){ -->

<!--     par[j, 1:npars] ~ dmnorm(mu_par[1:npars], cholesky = U[1:npars, 1:npars], prec_param = 0) -->

<!--    bL[j] ~ dnorm(mubL, sd = sbL) -->

<!--    bP[j] ~ dnorm(mubP, sd = sbP) -->

<!--    bK[j] ~ dnorm(mubL, sd = sbK) -->

<!--   } -->

<!--   mu_par[1] ~ dnorm(100, sd = 50) # L1 -->

<!--   mu_par[2] ~ dnorm(-1, sd = 0.5) # P -->

<!--   mu_par[3] ~ dnorm(1300, sd = 100) # L2 -->

<!--   mu_par[4] ~ dnorm(0.43, sd = 0.4) # K -->

<!--   sig_par[1] ~ dexp(1/(50/4)) -->

<!--   sig_par[2] ~ dexp(1/(0.5/4)) -->

<!--   sig_par[3] ~ dexp(1/(100/4)) -->

<!--   sig_par[4] ~ dexp(1/(0.4/4)) -->

<!--   mubL ~ dnorm(0, 0.01) -->

<!--   mubP ~ dnorm(0, 0.01) -->

<!--   mubK ~ dnorm(0, 0.01) -->

<!--   sbL ~ dlnorm(0, 1) -->

<!--   sbP ~ dlnorm(0, 1) -->

<!--   sbK ~ dlnorm(0, 1) -->

<!--   # # Calculate Linf and K -->

<!--   #Linf  <- ( (exp(par[1]*A2)*L2^par[2] - (exp(par[1]*A1)*L1^par[2])) / (exp(par[1]*A2) - exp(par[1]*A1)) )^(1/par[1]) -->

<!--   #t0 <- A1 + A2 - (1/par[2])*log(Linf) -->

<!-- }) -->

<!-- # Function creating the Cholesky of the covar. matrix (p45 Nimble manual) -->

<!-- uppertri_mult_diag <- nimbleFunction( -->

<!--   run = function(mat = double(2), vec = double(1)) { -->

<!--     returnType(double(2)) -->

<!--     p <- length_mm(vec) -->

<!--     out <- matrix(nrow = p, ncol = p, init = FALSE) -->

<!--     for(k in 1:p) -->

<!--       out[ , k] <- mat[ , k] * vec[k] -->

<!--     return(out) -->

<!--    # turn off buildDerivs for the i index -->

<!-- }, buildDerivs = list(run = list(ignore = c('k'))))  -->

<!-- # initial values generating function (par[1:4] = L1,p,L2,K) -->

<!-- inits <- function(){ -->

<!--   list(mu_par = c(rnorm(1, 100, 0.01), -->

<!--                   rnorm(1, 1000, 0.01), -->

<!--                   rnorm(1, 0, 0.01)), -->

<!--        P = rnorm(1,-2.5,1), -->

<!--        sig_par = c(rexp(1,1/(50/4)), -->

<!--                    rexp(1,1/(100/4)), -->

<!--                    rexp(1,1/(0.4/4))))} -->

<!-- data <- sallaa %>% -->

<!--   filter(!age.type == "sea.only") %>% -->

<!--   mutate(su = as.integer(factor(spat.unit))) %>% -->

<!--   drop_na(su) -->

<!-- npars <- 4 -->

<!-- A1 <- min(data$age.tot) -->

<!-- A2 <- max(data$age.tot) -->

<!-- # build model -->

<!-- fec2b.model <- nimbleModel(fec2b.code, -->

<!--                         constants = list(npars=npars, -->

<!--                                          A1 = A1, -->

<!--                                          A2 = A2, -->

<!--                                          nobs = nrow(data), -->

<!--                                          nsu = length_mm(unique(data$su)), -->

<!--                                          su = data$su -->

<!--                                          ), -->

<!--                         #inits=inits(), -->

<!--                         data = data %>% select(age.tot,length_mm) -->

<!--                         ,buildDerivs = TRUE) -->

<!-- ``` -->
